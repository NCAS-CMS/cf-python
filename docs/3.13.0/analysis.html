
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Analysis &#8212; Documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/customise-alabaster.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/clipboard.min.js"></script>
    <script type="text/javascript" src="_static/copybutton.js"></script>
    <script type="text/javascript" src="_static/toggleprompt.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API reference" href="api_reference.html" />
    <link rel="prev" title="Tutorial" href="tutorial.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">



<h1 class="logo"><a href="index.html">cf 3.13.0</a></h1>



<p class="blurb">A CF-compliant earth science data analysis library</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=NCAS-CMS&repo=cf-python&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html"><strong>Introduction</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="cf_data_model.html"><strong>CF data model</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html"><strong>Installation</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html"><strong>Contributing</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html"><strong>Tutorial</strong></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><strong>Analysis</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="api_reference.html"><strong>API reference</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="aggregation_rules.html"><strong>Aggregation rules</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="performance.html"><strong>Performance</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="releases.html"><strong>Releases</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="Changelog.html"><strong>Change log</strong></a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="tutorial.html" title="previous chapter"><strong>Tutorial</strong></a></li>
      <li>Next: <a href="api_reference.html" title="next chapter"><strong>API reference</strong></a></li>
  </ul></li>
</ul>
</div>

<br>
cf development has been supported by
the <a href="https://erc.europa.eu/">ERC</a>
through <a href="https://cordis.europa.eu/project/id/247220">Seachange</a>
and
<a href="https://cordis.europa.eu/project/id/786427">Couplet</a>; by
the <a href="https://ec.europa.eu/programmes/horizon2020/">EC Horizon
2020 programme</a> through
<a href="https://cordis.europa.eu/project/id/824084">IS-ENES3</a>;
by <a href="https://nerc.ukri.org/">NERC</a> through
<a href="https://gtr.ukri.org/project/0D95A6DB-0B95-48F7-8A8B-7B9A47DEA117">UKFAFMIP</a>;
and by <a href="https://ncas.ac.uk/">NCAS</a>.
<br>
<br>
<img src="_templates/logo_EC.png" height="40">
<img src="_templates/logo_ERC.png" height="40">
<img src="_templates/logo_NERC.png" height="40">
<br>
<img src="_templates/logo_NCAS.png" height="40">
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="analysis">
<span id="id1"></span><h1><strong>Analysis</strong><a class="headerlink" href="#analysis" title="Permalink to this headline">¶</a></h1>
<hr class="docutils" />
<p>Version 3.13.0 for version 1.9 of the CF conventions.</p>
<p>All of the Python code in this tutorial is available in an executable
script (<a class="reference download internal" download="" href="_downloads/field_analysis.py"><code class="xref download docutils literal notranslate"><span class="pre">download</span></code></a>, 8kB).</p>
<p>Note that this page is duplicated in the <a class="reference internal" href="tutorial.html#tutorial"><span class="std std-ref">tutorial</span></a>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p><strong>This version of cf is for Python 3 only</strong> and there are
<a class="reference internal" href="2_to_3_changes.html#two-to-three-changes"><span class="std std-ref">incompatible differences between versions 2.x and 3.x</span></a> of cf.</p>
<p>Scripts written for version 2.x but running under version
3.x should either work as expected, or provide informative
error messages on the new API usage. However, it is advised
that the outputs of older scripts are checked when running
with Python 3 versions of the cf library.</p>
<p>For version 2.x documentation, see the <a class="reference internal" href="releases.html#releases"><span class="std std-ref">releases</span></a> page.</p>
</div>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#sample-datasets" id="id84"><strong>Sample datasets</strong></a></p></li>
<li><p><a class="reference internal" href="#statistical-collapses" id="id85"><strong>Statistical collapses</strong></a></p>
<ul>
<li><p><a class="reference internal" href="#collapse-methods" id="id86">Collapse methods</a></p></li>
<li><p><a class="reference internal" href="#data-type-and-missing-data" id="id87">Data type and missing data</a></p></li>
<li><p><a class="reference internal" href="#collapse-weights" id="id88">Collapse weights</a></p></li>
<li><p><a class="reference internal" href="#multiple-collapses" id="id89">Multiple collapses</a></p></li>
<li><p><a class="reference internal" href="#grouped-collapses" id="id90">Grouped collapses</a></p></li>
<li><p><a class="reference internal" href="#climatological-statistics" id="id91">Climatological statistics</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#other-statistical-operations" id="id92"><strong>Other statistical operations</strong></a></p>
<ul>
<li><p><a class="reference internal" href="#cumulative-sums" id="id93">Cumulative sums</a></p></li>
<li><p><a class="reference internal" href="#histograms" id="id94">Histograms</a></p></li>
<li><p><a class="reference internal" href="#binning-operations" id="id95">Binning operations</a></p></li>
<li><p><a class="reference internal" href="#percentiles" id="id96">Percentiles</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#regridding" id="id97"><strong>Regridding</strong></a></p>
<ul>
<li><p><a class="reference internal" href="#regridding-methods" id="id98">Regridding methods</a></p></li>
<li><p><a class="reference internal" href="#spherical-regridding" id="id99">Spherical regridding</a></p></li>
<li><p><a class="reference internal" href="#cartesian-regridding" id="id100">Cartesian regridding</a></p></li>
<li><p><a class="reference internal" href="#regridding-masked-data" id="id101">Regridding masked data</a></p></li>
<li><p><a class="reference internal" href="#vertical-regridding" id="id102">Vertical regridding</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#mathematical-operations" id="id103"><strong>Mathematical operations</strong></a></p>
<ul>
<li><p><a class="reference internal" href="#binary-arithmetical-operations" id="id104">Binary arithmetical operations</a></p></li>
<li><p><a class="reference internal" href="#unary-operations" id="id105">Unary operations</a></p></li>
<li><p><a class="reference internal" href="#relational-operations" id="id106">Relational operations</a></p></li>
<li><p><a class="reference internal" href="#arithmetical-and-relational-operations-with-insufficient-metadata" id="id107">Arithmetical and relational operations with insufficient metadata</a></p></li>
<li><p><a class="reference internal" href="#operating-on-the-field-constructs-data" id="id108">Operating on the field constructs’ data</a></p></li>
<li><p><a class="reference internal" href="#trigonometrical-and-hyperbolic-functions" id="id109">Trigonometrical and hyperbolic functions</a></p></li>
<li><p><a class="reference internal" href="#exponential-and-logarithmic-functions" id="id110">Exponential and logarithmic functions</a></p></li>
<li><p><a class="reference internal" href="#rounding-and-truncation" id="id111">Rounding and truncation</a></p></li>
<li><p><a class="reference internal" href="#moving-windows" id="id112">Moving windows</a></p></li>
<li><p><a class="reference internal" href="#convolution-filters" id="id113">Convolution filters</a></p></li>
<li><p><a class="reference internal" href="#general-first-order-derivative" id="id114">General first order derivative</a></p></li>
<li><p><a class="reference internal" href="#gradient-vector" id="id115">Gradient vector</a></p></li>
<li><p><a class="reference internal" href="#laplacian" id="id116">Laplacian</a></p></li>
<li><p><a class="reference internal" href="#divergence" id="id117">Divergence</a></p></li>
<li><p><a class="reference internal" href="#curl" id="id118">Curl</a></p></li>
<li><p><a class="reference internal" href="#relative-vorticity" id="id119">Relative vorticity</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="sample-datasets">
<span id="id2"></span><h2><a class="toc-backref" href="#id84"><strong>Sample datasets</strong></a><a class="headerlink" href="#sample-datasets" title="Permalink to this headline">¶</a></h2>
<p>This tutorial uses a number of small sample datasets, all of which can
be found in the zip file <code class="docutils literal notranslate"><span class="pre">cf_tutorial_files.zip</span></code>
(<a class="reference download internal" download="" href="_downloads/cf_tutorial_files.zip"><code class="xref download docutils literal notranslate"><span class="pre">download</span></code></a>,
164kB):</p>
<div class="literal-block-wrapper docutils container" id="id27">
<div class="code-block-caption"><span class="caption-text"><em>Unpack the sample datasets.</em></span><a class="headerlink" href="#id27" title="Permalink to this code">¶</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> unzip -q cf_tutorial_files.zip
<span class="gp">$</span> ls -1
<span class="go">air_temperature.nc</span>
<span class="go">cf_tutorial_files.zip</span>
<span class="go">contiguous.nc</span>
<span class="go">external.nc</span>
<span class="go">file2.nc</span>
<span class="go">file.nc</span>
<span class="go">gathered.nc</span>
<span class="go">parent.nc</span>
<span class="go">precipitation_flux.nc</span>
<span class="go">timeseries.nc</span>
<span class="go">umfile.pp</span>
<span class="go">vertical.nc</span>
<span class="go">wind_components.nc</span>
</pre></div>
</div>
</div>
<p>The tutorial examples assume that the Python session is being run from
the directory that contains the zip file and its unpacked contents,
and no other files.</p>
<p>The tutorial files may be also found in the <a class="reference external" href="https://github.com/NCAS-CMS/cf-python/tree/master/docs/_downloads">downloads directory</a>
of the on-line code repository.</p>
<hr class="docutils" />
</section>
<section id="statistical-collapses">
<span id="id3"></span><h2><a class="toc-backref" href="#id85"><strong>Statistical collapses</strong></a><a class="headerlink" href="#statistical-collapses" title="Permalink to this headline">¶</a></h2>
<p>Collapsing one or more dimensions reduces their size and replaces the
data along those axes with representative statistical values. The
result is a new field construct with consistent metadata for the
collapsed values. Collapses are carried with the <a class="reference internal" href="method/cf.Field.collapse.html#cf.Field.collapse" title="cf.Field.collapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">collapse</span></code></a>
method of the field construct.</p>
<p>By default all axes with size greater than 1 are collapsed completely
(i.e. to size 1) with a given <a class="reference internal" href="field_analysis.html#collapse-methods"><span class="std std-ref">collapse method</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="id28">
<div class="code-block-caption"><span class="caption-text"><em>Find the minimum of the entire data.</em></span><a class="headerlink" href="#id28" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;timeseries.nc&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(120), latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean</span>
<span class="go">Dimension coords: time(120) = [1959-12-16 12:00:00, ..., 1969-11-16 00:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;minimum&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(1), latitude(1), longitude(1)) K</span>
<span class="go">Cell methods    : area: mean time(1): latitude(1): longitude(1): minimum</span>
<span class="go">Dimension coords: time(1) = [1964-11-30 12:00:00]</span>
<span class="go">                : latitude(1) = [0.0] degrees_north</span>
<span class="go">                : longitude(1) = [180.0] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[[198.9]]]</span>
</pre></div>
</div>
</div>
<p>In the above example, note that the operation has been recorded in a
new cell method construct (<code class="docutils literal notranslate"><span class="pre">time(1):</span> <span class="pre">latitude(1):</span> <span class="pre">longitude(1):</span>
<span class="pre">minimum</span></code>) in the output field construct, and the dimension coordinate
constructs each now have a single cell. The air pressure time
dimension was not included in the collapse because it already had size
1 in the original field construct.</p>
<p>The collapse can also be applied to any subset of the field
construct’s dimensions. In this case, the domain axis and coordinate
constructs for the non-collapsed dimensions remain the same. This is
implemented either with the <em>axes</em> keyword, or with a <a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#cell-methods">CF-netCDF cell
methods</a>-like syntax for describing both the collapse dimensions
and the collapse method in a single string. The latter syntax uses
<a class="reference internal" href="tutorial.html#construct-identities"><span class="std std-ref">construct identities</span></a> instead of netCDF
dimension names to identify the collapse axes.</p>
<p>Statistics may be created to represent variation over one dimension or
a combination of dimensions.</p>
<div class="literal-block-wrapper docutils container" id="id29">
<div class="code-block-caption"><span class="caption-text"><em>Two equivalent techniques for creating a field construct
of temporal maxima at each horizontal location.</em></span><a class="headerlink" href="#id29" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;maximum&#39;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;T: maximum&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(1), latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean time(1): maximum</span>
<span class="go">Dimension coords: time(1) = [1964-11-30 12:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[[310.6 309.1 309.9 311.2 310.4 310.1 310.7 309.6]</span>
<span class="go">  [310.  310.7 311.1 311.3 310.9 311.2 310.6 310. ]</span>
<span class="go">  [308.9 309.8 311.2 311.2 311.2 309.3 311.1 310.7]</span>
<span class="go">  [310.1 310.3 308.8 311.1 310.  311.3 311.2 309.7]</span>
<span class="go">  [310.9 307.9 310.3 310.4 310.8 310.9 311.3 309.3]]]</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id30">
<div class="code-block-caption"><span class="caption-text"><em>Find the horizontal maximum, with two equivalent
techniques.</em></span><a class="headerlink" href="#id30" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;maximum&#39;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;X: Y: maximum&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(120), latitude(1), longitude(1)) K</span>
<span class="go">Cell methods    : area: mean latitude(1): longitude(1): maximum</span>
<span class="go">Dimension coords: time(120) = [1959-12-16 12:00:00, ..., 1969-11-16 00:00:00]</span>
<span class="go">                : latitude(1) = [0.0] degrees_north</span>
<span class="go">                : longitude(1) = [180.0] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
</pre></div>
</div>
</div>
<p>Variation over horizontal area may also be specified by the special
identity <code class="docutils literal notranslate"><span class="pre">'area'</span></code>. This may be used for any horizontal coordinate
reference system.</p>
<div class="literal-block-wrapper docutils container" id="id31">
<div class="code-block-caption"><span class="caption-text"><em>Find the horizontal maximum using the special identity
‘area’.</em></span><a class="headerlink" href="#id31" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;area: maximum&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(120), latitude(1), longitude(1)) K</span>
<span class="go">Cell methods    : area: mean area: maximum</span>
<span class="go">Dimension coords: time(120) = [1959-12-16 12:00:00, ..., 1969-11-16 00:00:00]</span>
<span class="go">                : latitude(1) = [0.0] degrees_north</span>
<span class="go">                : longitude(1) = [180.0] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
</pre></div>
</div>
</div>
<section id="collapse-methods">
<span id="id4"></span><h3><a class="toc-backref" href="#id86">Collapse methods</a><a class="headerlink" href="#collapse-methods" title="Permalink to this headline">¶</a></h3>
<p>The following collapse methods are available, over any subset of the
domain axes. The “Cell method” column in the table gives the method of
the new cell method construct (if one is created).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 43%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Cell method</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'maximum'</span></code></p></td>
<td><p>The maximum of the values.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">maximum</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'minimum'</span></code></p></td>
<td><p>The minimum of the values.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">minimum</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'maximum_absolute_value'</span></code></p></td>
<td><p>The maximum of the absolute values.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">maximum_absolute_value</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'minimum_absolute_value'</span></code></p></td>
<td><p>The minimum of the absolute values.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">minimum_absolute_value</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'mid_range'</span></code></p></td>
<td><p>The average of the maximum and the
minimum of the values.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mid_range</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'range'</span></code></p></td>
<td><p>The absolute difference between the
maximum and the minimum of the values.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">range</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'median'</span></code></p></td>
<td><p>The median of the values.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">median</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'sample_size'</span></code></p></td>
<td><p>The sample size, <span class="math notranslate nohighlight">\(N\)</span>, as would be
used for other calculations, i.e. the
number of non-missing values.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">point</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'sum_of_weights'</span></code></p></td>
<td><p>The sum of <span class="math notranslate nohighlight">\(N\)</span> weights
<span class="math notranslate nohighlight">\(w_i\)</span>, as would be used for other
calculations, is</p>
<div class="math notranslate nohighlight">
\[V_{1}=\sum_{i=1}^{N} w_i\]</div>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">sum</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'sum_of_weights2'</span></code></p></td>
<td><p>The sum of the squares of <span class="math notranslate nohighlight">\(N\)</span>
weights <span class="math notranslate nohighlight">\(w_i\)</span>, as would be used
for other calculations, is</p>
<div class="math notranslate nohighlight">
\[V_{2}=\sum_{i=1}^{N}  w_i^{2}\]</div>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">sum</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'sum'</span></code></p></td>
<td><p>The unweighted sum of <span class="math notranslate nohighlight">\(N\)</span> values
<span class="math notranslate nohighlight">\(x_i\)</span> is</p>
<div class="math notranslate nohighlight">
\[t=\sum_{i=1}^{N} x_i\]</div>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">sum</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'sum_of_squares'</span></code></p></td>
<td><p>The unweighted sum of the squares of
<span class="math notranslate nohighlight">\(N\)</span> values <span class="math notranslate nohighlight">\(x_i\)</span> is</p>
<div class="math notranslate nohighlight">
\[t_2=\sum_{i=1}^{N} x_{i}^{2}\]</div>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">sum_of_squares</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'integral'</span></code></p></td>
<td><p>The integral of <span class="math notranslate nohighlight">\(N\)</span> values
<span class="math notranslate nohighlight">\(x_i\)</span> with corresponding cell
measures <span class="math notranslate nohighlight">\(m_i\)</span> is</p>
<div class="math notranslate nohighlight">
\[i=\sum_{i=1}^{N} m_i x_i\]</div>
<p>Note that the integral differs from a
weighted sum in that the units of the
cell measures are incorporated into the
result.</p>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">sum</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'mean'</span></code></p></td>
<td><p>The unweighted mean of <span class="math notranslate nohighlight">\(N\)</span> values
<span class="math notranslate nohighlight">\(x_i\)</span> is</p>
<div class="math notranslate nohighlight">
\[\mu=\frac{1}{N}\sum_{i=1}^{N}
x_i\]</div>
<p>The <a class="reference internal" href="field_analysis.html#collapse-weights"><span class="std std-ref">weighted</span></a>
mean of <span class="math notranslate nohighlight">\(N\)</span> values <span class="math notranslate nohighlight">\(x_i\)</span>
with corresponding weights <span class="math notranslate nohighlight">\(w_i\)</span>
is</p>
<div class="math notranslate nohighlight">
\[\hat{\mu}=\frac{1}{V_{1}}
           \sum_{i=1}^{N}
w_i x_i\]</div>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">mean</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'mean_absolute_value'</span></code></p></td>
<td><p>The unweighted mean of <span class="math notranslate nohighlight">\(N\)</span>
values <span class="math notranslate nohighlight">\(x_i\)</span> absoluted is</p>
<div class="math notranslate nohighlight">
\[\mu_{abs}=\frac{1}{N}
\sum_{i=1}^{N}|x_i|\]</div>
<p>The <a class="reference internal" href="field_analysis.html#collapse-weights"><span class="std std-ref">weighted</span></a>
mean of <span class="math notranslate nohighlight">\(N\)</span> values <span class="math notranslate nohighlight">\(x_i\)</span>
absoluted with corresponding weights
<span class="math notranslate nohighlight">\(w_i\)</span> is</p>
<div class="math notranslate nohighlight">
\[\hat{\mu}_{abs}=
\frac{1}{V_{1}}
\sum_{i=1}^{N} w_i |x_i|\]</div>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">mean_absolute_value</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'mean_of_upper_decile'</span></code></p></td>
<td><p>The weighted or unweighted mean of the
upper group of data values defined by
the upper tenth of their distribution</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mean_of_upper_decile</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'variance'</span></code></p></td>
<td><p>The unweighted variance of <span class="math notranslate nohighlight">\(N\)</span>
values <span class="math notranslate nohighlight">\(x_i\)</span> and with
<span class="math notranslate nohighlight">\(N-ddof\)</span> degrees of freedom
(<span class="math notranslate nohighlight">\(ddof\ge0\)</span>) is</p>
<div class="math notranslate nohighlight">
\[s_{N-ddof}^{2}=
\frac{1}{N-ddof}
\sum_{i=1}^{N} (x_i - \mu)^2\]</div>
<p>The unweighted biased estimate of the
variance (<span class="math notranslate nohighlight">\(s_{N}^{2}\)</span>) is given by
<span class="math notranslate nohighlight">\(ddof=0\)</span> and the unweighted
unbiased estimate of the variance using
Bessel’s correction
(<span class="math notranslate nohighlight">\(s^{2}=s_{N-1}^{2}\)</span>) is given by
<span class="math notranslate nohighlight">\(ddof=1\)</span>.</p>
<p>The <a class="reference internal" href="field_analysis.html#collapse-weights"><span class="std std-ref">weighted</span></a>
biased estimate of the variance of
<span class="math notranslate nohighlight">\(N\)</span> values <span class="math notranslate nohighlight">\(x_i\)</span> with
corresponding weights <span class="math notranslate nohighlight">\(w_i\)</span> is</p>
<div class="math notranslate nohighlight">
\[\hat{s}_{N}^{2}=
\frac{1}{V_{1}}
\sum_{i=1}^{N}
w_i(x_i -
\hat{\mu})^{2}\]</div>
<p>The corresponding <a class="reference internal" href="field_analysis.html#collapse-weights"><span class="std std-ref">weighted</span></a> unbiased estimate of
the variance is</p>
<div class="math notranslate nohighlight">
\[\hat{s}^{2}=\frac{1}{V_{1} -
(V_{1}/V_{2})}
\sum_{i=1}^{N}
w_i(x_i -
\hat{\mu})^{2}\]</div>
<p>In both cases, the weights are assumed
to be non-random reliability weights, as
opposed to frequency weights.</p>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">variance</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'standard_deviation'</span></code></p></td>
<td><p>The standard deviation is the square
root of the unweighted or
<a class="reference internal" href="field_analysis.html#collapse-weights"><span class="std std-ref">weighted</span></a>
variance, as defined in this table.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">standard_deviation</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'root_mean_square'</span></code></p></td>
<td><p>The unweighted root mean square of
<span class="math notranslate nohighlight">\(N\)</span> values <span class="math notranslate nohighlight">\(x_i\)</span> is</p>
<div class="math notranslate nohighlight">
\[RMS=\sqrt{\frac{1}{N}
\sum_{i=1}^{N}
x_{i}^2}\]</div>
<p>The <a class="reference internal" href="field_analysis.html#collapse-weights"><span class="std std-ref">weighted</span></a>
root mean square of <span class="math notranslate nohighlight">\(N\)</span> values
<span class="math notranslate nohighlight">\(x_i\)</span> with corresponding weights
<span class="math notranslate nohighlight">\(w_i\)</span> is</p>
<div class="math notranslate nohighlight">
\[\hat{RMS}=\sqrt{
\frac{1}{V_{1}}
\sum_{i=1}^{N} w_i
x_{i}^2}\]</div>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">root_mean_square</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="data-type-and-missing-data">
<span id="id5"></span><h3><a class="toc-backref" href="#id87">Data type and missing data</a><a class="headerlink" href="#data-type-and-missing-data" title="Permalink to this headline">¶</a></h3>
<p>In all collapses, missing data array elements are accounted for in the
calculation.</p>
<p>Any collapse method that involves a calculation (such as calculating a
mean), as opposed to just selecting a value (such as finding a
maximum), will return a field containing double precision floating
point numbers. If this is not desired then the data type can be reset
after the collapse with the <a class="reference internal" href="attribute/cf.Field.dtype.html#cf.Field.dtype" title="cf.Field.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a> attribute of the field
construct.</p>
</section>
<section id="collapse-weights">
<span id="id6"></span><h3><a class="toc-backref" href="#id88">Collapse weights</a><a class="headerlink" href="#collapse-weights" title="Permalink to this headline">¶</a></h3>
<p>For weights to be incorporated in the collapse, the axes to be
weighted must be identified with the <em>weights</em> keyword. A collapse by
a particular method is either never weighted, or may be weighted, or
is always weighted, as described in the following table:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 44%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Weighted</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'maximum'</span></code></p></td>
<td><p>The maximum of the values.</p></td>
<td><p>Never</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'minimum'</span></code></p></td>
<td><p>The minimum of the values.</p></td>
<td><p>Never</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'maximum_absolute_value'</span></code></p></td>
<td><p>The maximum of the absolute.</p></td>
<td><p>Never</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'minimum_absolute_value'</span></code></p></td>
<td><p>The minimum of the absolute.</p></td>
<td><p>Never</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'mid_range'</span></code></p></td>
<td><p>The average of the maximum
and the minimum of the
values.</p></td>
<td><p>Never</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'range'</span></code></p></td>
<td><p>The absolute difference
between the maximum and the
minimum of the values.</p></td>
<td><p>Never</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'median'</span></code></p></td>
<td><p>The median of the values.</p></td>
<td><p>Never</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'sum'</span></code></p></td>
<td><p>The sum of the values.</p></td>
<td><p>Never</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'sum_of_squares'</span></code></p></td>
<td><p>The sum of the squares of
values.</p></td>
<td><p>Never</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'sample_size'</span></code></p></td>
<td><p>The sample size, i.e. the
number of non-missing
values.</p></td>
<td><p>Never</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'sum_of_weights'</span></code></p></td>
<td><p>The sum of weights, as
would be used for other
calculations.</p></td>
<td><p>Never</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'sum_of_weights2'</span></code></p></td>
<td><p>The sum of squares of
weights, as would be used
for other calculations.</p></td>
<td><p>Never</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'mean'</span></code></p></td>
<td><p>The weighted or unweighted
mean of the values.</p></td>
<td><p>May be</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'mean_absolute_value'</span></code></p></td>
<td><p>The mean of the absolute
values.</p></td>
<td><p>May be</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'mean_of_upper_decile'</span></code></p></td>
<td><p>The mean of the upper group
of data values defined by
the upper tenth of their
distribution.</p></td>
<td><p>May be</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'variance'</span></code></p></td>
<td><p>The weighted or unweighted
variance of the values, with
a given number of degrees of
freedom.</p></td>
<td><p>May be</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'standard_deviation'</span></code></p></td>
<td><p>The weighted or unweighted
standard deviation of the
values with a given number
of degrees of freedom.</p></td>
<td><p>May be</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'root_mean_square'</span></code></p></td>
<td><p>The square root of the
weighted or unweighted mean
of the squares of the
values.</p></td>
<td><p>May be</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'integral'</span></code></p></td>
<td><p>The integral of values.</p></td>
<td><p>Always</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Collapse methods that are “Never” weighted ignore the <em>weights</em>
parameter, even if it is set.</p></li>
<li><p>Collapse methods that “May be” weighted will only be weighted if the
<em>weights</em> parameter is set.</p></li>
<li><p>Collapse methods that are “Always” weighted require the <em>weights</em>
parameter to be set.</p></li>
</ul>
<p>Weights are either derived from the field construct’s metadata (such
as cell sizes), or may be provided explicitly in the form of other
field constructs containing data of weights values. In either case,
the weights actually used are those derived by the <a class="reference internal" href="method/cf.Field.weights.html#cf.Field.weights" title="cf.Field.weights"><code class="xref py py-obj docutils literal notranslate"><span class="pre">weights</span></code></a>
method of the field construct called with the same <em>weights</em> keyword
value. Collapsed axes that are not identified by the <em>weights</em> keyword
are unweighted during the collapse operation.</p>
<div class="literal-block-wrapper docutils container" id="id32">
<div class="code-block-caption"><span class="caption-text"><em>Create a weighted time average.</em></span><a class="headerlink" href="#id32" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;T: mean&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(1), latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean time(1): mean</span>
<span class="go">Dimension coords: time(1) = [1964-11-30 12:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[[254.03120723 255.89723515 253.06490556 254.17815494 255.18458801 253.3684369  253.26624692 253.63818779]</span>
<span class="go">  [248.92058582 253.99597591 259.67957843 257.08967972 252.57333698 252.5746236  258.90938954 253.86939502]</span>
<span class="go">  [255.94716671 254.77330961 254.35929373 257.91478237 251.87670408 252.72723789 257.26038872 258.19698878]</span>
<span class="go">  [258.08639474 254.8087873  254.9881741  250.98064604 255.3513003  256.66337257 257.86895702 259.49299206]</span>
<span class="go">  [263.80016425 253.35825349 257.8026006  254.3173556  252.2061867  251.74150014 255.60930742 255.06260608]]]</span>
</pre></div>
</div>
</div>
<p>To inspect the weights, call the  <a class="reference internal" href="method/cf.Field.weights.html#cf.Field.weights" title="cf.Field.weights"><code class="xref py py-obj docutils literal notranslate"><span class="pre">weights</span></code></a> method directly.</p>
<div class="literal-block-wrapper docutils container" id="id33">
<div class="code-block-caption"><span class="caption-text"><em>Create and view weights derived from the field construct’s
time axis.</em></span><a class="headerlink" href="#id33" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">weights</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">Field: long_name=weights (ncvar%air_potential_temperature)</span>
<span class="go">----------------------------------------------------------</span>
<span class="go">Data            : long_name=weights(time(120)) d</span>
<span class="go">Dimension coords: time(120) = [1959-12-16 12:00:00, ..., 1969-11-16 00:00:00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[31. 31. 29. 31. 30. 31. 30. 31. 31. 30. 31. 30. 31. 31. 28. 31. 30. 31.</span>
<span class="go"> 30. 31. 31. 30. 31. 30. 31. 31. 28. 31. 30. 31. 30. 31. 31. 30. 31. 30.</span>
<span class="go"> 31. 31. 28. 31. 30. 31. 30. 31. 31. 30. 31. 30. 31. 31. 29. 31. 30. 31.</span>
<span class="go"> 30. 31. 31. 30. 31. 30. 31. 31. 28. 31. 30. 31. 30. 31. 31. 30. 31. 30.</span>
<span class="go"> 31. 31. 28. 31. 30. 31. 30. 31. 31. 30. 31. 30. 31. 31. 28. 31. 30. 31.</span>
<span class="go"> 30. 31. 31. 30. 31. 30. 31. 31. 29. 31. 30. 31. 30. 31. 31. 30. 31. 30.</span>
<span class="go"> 31. 31. 28. 31. 30. 31. 30. 31. 31. 30. 31. 30.]</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id34">
<div class="code-block-caption"><span class="caption-text"><em>Calculate the mean over the time and latitude axes, with
weights only applied to the latitude axis.</em></span><a class="headerlink" href="#id34" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;T: Y: mean&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(1), latitude(1), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean time(1): latitude(1): mean</span>
<span class="go">Dimension coords: time(1) = [1964-11-30 12:00:00]</span>
<span class="go">                : latitude(1) = [0.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[[256.15819444 254.625      255.73666667 255.43041667 253.19444444 253.31277778 256.68236111 256.42055556]]]</span>
</pre></div>
</div>
</div>
<p>Specifying weighting by horizontal cell area may also use the special
<code class="docutils literal notranslate"><span class="pre">'area'</span></code> syntax.</p>
<div class="literal-block-wrapper docutils container" id="id35">
<div class="code-block-caption"><span class="caption-text"><em>Alternative syntax for specifying area weights.</em></span><a class="headerlink" href="#id35" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;area: mean&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(120), latitude(1), longitude(1)) K</span>
<span class="go">Cell methods    : area: mean area: mean</span>
<span class="go">Dimension coords: time(120) = [1959-12-16 12:00:00, ..., 1969-11-16 00:00:00]</span>
<span class="go">                : latitude(1) = [0.0] degrees_north</span>
<span class="go">                : longitude(1) = [180.0] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
</pre></div>
</div>
</div>
<p>An alternative technique for specifying weights is to set the
<em>weights</em> keyword to the output of a call to the <a class="reference internal" href="method/cf.Field.weights.html#cf.Field.weights" title="cf.Field.weights"><code class="xref py py-obj docutils literal notranslate"><span class="pre">weights</span></code></a>
method.</p>
<div class="literal-block-wrapper docutils container" id="id36">
<div class="code-block-caption"><span class="caption-text"><em>Alternative syntax for specifying weights.</em></span><a class="headerlink" href="#id36" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;area: mean&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">weights</span><span class="p">(</span><span class="s1">&#39;area&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(120), latitude(1), longitude(1)) K</span>
<span class="go">Cell methods    : area: mean area: mean</span>
<span class="go">Dimension coords: time(120) = [1959-12-16 12:00:00, ..., 1969-11-16 00:00:00]</span>
<span class="go">                : latitude(1) = [0.0] degrees_north</span>
<span class="go">                : longitude(1) = [180.0] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
</pre></div>
</div>
</div>
<p>See the <a class="reference internal" href="method/cf.Field.weights.html#cf.Field.weights" title="cf.Field.weights"><code class="xref py py-obj docutils literal notranslate"><span class="pre">weights</span></code></a> method for full details on how weights may be
specified.</p>
</section>
<section id="multiple-collapses">
<span id="id7"></span><h3><a class="toc-backref" href="#id89">Multiple collapses</a><a class="headerlink" href="#multiple-collapses" title="Permalink to this headline">¶</a></h3>
<p>Multiple collapses normally require multiple calls to
<a class="reference internal" href="method/cf.Field.collapse.html#cf.Field.collapse" title="cf.Field.collapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">collapse</span></code></a>: one on the original field construct and then one on
each interim field construct.</p>
<div class="literal-block-wrapper docutils container" id="id37">
<div class="code-block-caption"><span class="caption-text"><em>Calculate the temporal maximum of the weighted areal
means using two independent calls.</em></span><a class="headerlink" href="#id37" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;area: mean&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;T: maximum&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(1), latitude(1), longitude(1)) K</span>
<span class="go">Cell methods    : area: mean latitude(1): longitude(1): mean time(1): maximum</span>
<span class="go">Dimension coords: time(1) = [1964-11-30 12:00:00]</span>
<span class="go">                : latitude(1) = [0.0] degrees_north</span>
<span class="go">                : longitude(1) = [180.0] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[[271.77199724]]]</span>
</pre></div>
</div>
</div>
<p>If preferred, multiple collapses may be carried out in a single call
to <a class="reference internal" href="method/cf.Field.collapse.html#cf.Field.collapse" title="cf.Field.collapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">collapse</span></code></a> by using the <a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#cell-methods">CF-netCDF cell methods</a>-like
syntax (note that the colon (<code class="docutils literal notranslate"><span class="pre">:</span></code>) is only used after the construct
identity that specifies each axis, and a space delimits the separate
collapses).</p>
<div class="literal-block-wrapper docutils container" id="id38">
<div class="code-block-caption"><span class="caption-text"><em>Calculate the temporal maximum of the weighted areal
means in a single call, using the cf-netCDF cell
methods-like syntax.</em></span><a class="headerlink" href="#id38" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;area: mean T: maximum&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[[271.77199724]]]</span>
</pre></div>
</div>
</div>
</section>
<section id="grouped-collapses">
<span id="id8"></span><h3><a class="toc-backref" href="#id90">Grouped collapses</a><a class="headerlink" href="#grouped-collapses" title="Permalink to this headline">¶</a></h3>
<p>A grouped collapse is one for which an axis is not collapsed
completely to size 1. Instead the collapse axis is partitioned into
non-overlapping groups and each group is collapsed to size 1. The
resulting axis will generally have more than one element. For example,
creating 12 annual means from a timeseries of 120 months would be a
grouped collapse. The groups do not need to be created from adjacent
cells, as would be the case when creating 12 multi-annual monthly
means from a timeseries of 120 months.</p>
<p>Selected statistics for overlapping groups can be calculated with the
<a class="reference internal" href="method/cf.Field.moving_window.html#cf.Field.moving_window" title="cf.Field.moving_window"><code class="xref py py-obj docutils literal notranslate"><span class="pre">moving_window</span></code></a> method of the field construct.</p>
<p>The <em>group</em> keyword of <a class="reference internal" href="method/cf.Field.collapse.html#cf.Field.collapse" title="cf.Field.collapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">collapse</span></code></a> defines the size of the
groups. Groups can be defined in a variety of ways, including with
<a class="reference internal" href="class/cf.Query.html#cf.Query" title="cf.Query"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.Query</span></code></a>, <a class="reference internal" href="class/cf.TimeDuration.html#cf.TimeDuration" title="cf.TimeDuration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.TimeDuration</span></code></a> (see the <a class="reference internal" href="tutorial.html#time-duration"><span class="std std-ref">Time duration</span></a> section)
and <a class="reference internal" href="class/cf.Data.html#cf.Data" title="cf.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.Data</span></code></a> instances.</p>
<p>An element of the collapse axis can not be a member of more than one
group, and may be a member of no groups. Elements that are not
selected by the <em>group</em> keyword are excluded from the result.</p>
<div class="literal-block-wrapper docutils container" id="id39">
<div class="code-block-caption"><span class="caption-text"><em>Create annual maxima from a time series, defining a year
to start on 1st January.</em></span><a class="headerlink" href="#id39" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="n">month</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">&lt;CF TimeDuration: P1Y (Y-12-01 00:00:00)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;T: maximum&#39;</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(10), latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean time(10): maximum</span>
<span class="go">Dimension coords: time(10) = [1960-06-01 00:00:00, ..., 1969-06-01 12:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id40">
<div class="code-block-caption"><span class="caption-text"><em>Find the maximum of each group of 6 elements along an
axis.</em></span><a class="headerlink" href="#id40" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;T: maximum&#39;</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(20), latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean time(20): maximum</span>
<span class="go">Dimension coords: time(20) = [1960-03-01 12:00:00, ..., 1969-08-31 12:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id41">
<div class="code-block-caption"><span class="caption-text"><em>Create December, January, February maxima from a time series.</em></span><a class="headerlink" href="#id41" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;T: maximum&#39;</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">djf</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(10), latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean time(10): maximum time(10): maximum</span>
<span class="go">Dimension coords: time(10) = [1960-01-15 12:00:00, ..., 1969-01-15 00:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id42">
<div class="code-block-caption"><span class="caption-text"><em>Create maxima for each 3-month season of a timeseries
(DJF, MAM, JJA, SON).</em></span><a class="headerlink" href="#id42" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">seasons</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">[&lt;CF Query: month[(ge 12) | (le 2)]&gt;</span>
<span class="go"> &lt;CF Query: month(wi (3, 5))&gt;,</span>
<span class="go"> &lt;CF Query: month(wi (6, 8))&gt;,</span>
<span class="go"> &lt;CF Query: month(wi (9, 11))&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;T: maximum&#39;</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(40), latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean time(40): maximum time(40): maximum</span>
<span class="go">Dimension coords: time(40) = [1960-01-15 12:00:00, ..., 1969-10-16 12:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id43">
<div class="code-block-caption"><span class="caption-text"><em>Calculate zonal means for the western and eastern
hemispheres.</em></span><a class="headerlink" href="#id43" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;X: mean&#39;</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">Data</span><span class="p">(</span><span class="mi">180</span><span class="p">,</span> <span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(120), latitude(5), longitude(2)) K</span>
<span class="go">Cell methods    : area: mean longitude(2): mean longitude(2): mean</span>
<span class="go">Dimension coords: time(120) = [1959-12-16 12:00:00, ..., 1969-11-16 00:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(2) = [90.0, 270.0] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
</pre></div>
</div>
</div>
<p>Groups can be further described with the <em>group_span</em> (to include
groups whose actual span is not equal to a given value) and the
<em>group_contiguous</em> (to include non-contiguous groups, or any
contiguous group containing overlapping cells) keywords of
<a class="reference internal" href="method/cf.Field.collapse.html#cf.Field.collapse" title="cf.Field.collapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">collapse</span></code></a>.</p>
</section>
<section id="climatological-statistics">
<span id="id9"></span><h3><a class="toc-backref" href="#id91">Climatological statistics</a><a class="headerlink" href="#climatological-statistics" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#climatological-statistics">Climatological statistics</a> may be derived from corresponding
portions of the annual cycle in a set of years (e.g. the average
January temperatures in the climatology of 1961-1990, where the values
are derived by averaging the 30 Januarys from the separate years); or
from corresponding portions of the diurnal cycle in a set of days
(e.g. the average temperatures for each hour in the day for May
1997). A diurnal climatology may also be combined with a multiannual
climatology (e.g. the minimum temperature for each hour of the average
day in May from a 1961-1990 climatology).</p>
<p>Calculation requires two or three collapses, depending on the quantity
being created, all of which are grouped collapses. Each collapse
method needs to indicate its climatological nature with one of the
following qualifiers,</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method qualifier</p></th>
<th class="head"><p>Associated keyword</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">within</span> <span class="pre">years</span></code></p></td>
<td><p><em>within_years</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">within</span> <span class="pre">days</span></code></p></td>
<td><p><em>within_days</em></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">over</span> <span class="pre">years</span></code></p></td>
<td><p><em>over_years</em> (optional)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">over</span> <span class="pre">days</span></code></p></td>
<td><p><em>over_days</em> (optional)</p></td>
</tr>
</tbody>
</table>
<p>and the associated keyword to <a class="reference internal" href="method/cf.Field.collapse.html#cf.Field.collapse" title="cf.Field.collapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">collapse</span></code></a> specifies how the
method is to be applied.</p>
<div class="literal-block-wrapper docutils container" id="id44">
<div class="code-block-caption"><span class="caption-text"><em>Calculate the multiannual average of the seasonal means.</em></span><a class="headerlink" href="#id44" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;T: mean within years T: mean over years&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">within_years</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">seasons</span><span class="p">(),</span> <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(4), latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean time(4): mean within years time(4): mean over years</span>
<span class="go">Dimension coords: time(4) = [1960-01-15 12:00:00, ..., 1960-10-16 12:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">datetime_array</span><span class="p">)</span>
<span class="go">[[cftime.DatetimeGregorian(1959-12-01 00:00:00) cftime.DatetimeGregorian(1969-03-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1960-03-01 00:00:00) cftime.DatetimeGregorian(1969-06-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1960-06-01 00:00:00) cftime.DatetimeGregorian(1969-09-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1960-09-01 00:00:00) cftime.DatetimeGregorian(1969-12-01 00:00:00)]]</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id45">
<div class="code-block-caption"><span class="caption-text"><em>Calculate the multiannual variance of the seasonal
minima. Note that the units of the result have been
changed from ‘K’ to ‘K2’.</em></span><a class="headerlink" href="#id45" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;T: minimum within years T: variance over years&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">within_years</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">seasons</span><span class="p">(),</span> <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(4), latitude(5), longitude(8)) K2</span>
<span class="go">Cell methods    : area: mean time(4): minimum within years time(4): variance over years</span>
<span class="go">Dimension coords: time(4) = [1960-01-15 12:00:00, ..., 1960-10-16 12:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">datetime_array</span><span class="p">)</span>
<span class="go">[[cftime.DatetimeGregorian(1959-12-01 00:00:00) cftime.DatetimeGregorian(1969-03-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1960-03-01 00:00:00) cftime.DatetimeGregorian(1969-06-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1960-06-01 00:00:00) cftime.DatetimeGregorian(1969-09-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1960-09-01 00:00:00) cftime.DatetimeGregorian(1969-12-01 00:00:00)]]</span>
</pre></div>
</div>
</div>
<p>When collapsing over years, it is assumed by default that the each
portion of the annual cycle is collapsed over all years that are
present. This is the case in the above two examples. It is possible,
however, to restrict the years to be included, or group them into
chunks, with the <em>over_years</em> keyword to <a class="reference internal" href="method/cf.Field.collapse.html#cf.Field.collapse" title="cf.Field.collapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">collapse</span></code></a>.</p>
<div class="literal-block-wrapper docutils container" id="id46">
<div class="code-block-caption"><span class="caption-text"><em>Calculate the multiannual average of the seasonal means
in 5 year chunks.</em></span><a class="headerlink" href="#id46" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;T: mean within years T: mean over years&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">within_years</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">seasons</span><span class="p">(),</span> <span class="n">over_years</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(8), latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean time(8): mean within years time(8): mean over years</span>
<span class="go">Dimension coords: time(8) = [1960-01-15 12:00:00, ..., 1965-10-16 12:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">datetime_array</span><span class="p">)</span>
<span class="go">[[cftime.DatetimeGregorian(1959-12-01 00:00:00) cftime.DatetimeGregorian(1964-03-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1960-03-01 00:00:00) cftime.DatetimeGregorian(1964-06-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1960-06-01 00:00:00) cftime.DatetimeGregorian(1964-09-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1960-09-01 00:00:00) cftime.DatetimeGregorian(1964-12-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1964-12-01 00:00:00) cftime.DatetimeGregorian(1969-03-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1965-03-01 00:00:00) cftime.DatetimeGregorian(1969-06-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1965-06-01 00:00:00) cftime.DatetimeGregorian(1969-09-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1965-09-01 00:00:00) cftime.DatetimeGregorian(1969-12-01 00:00:00)]]</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id47">
<div class="code-block-caption"><span class="caption-text"><em>Calculate the multiannual average of the seasonal means,
restricting the years from 1963 to 1968.</em></span><a class="headerlink" href="#id47" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;T: mean within years T: mean over years&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">within_years</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">seasons</span><span class="p">(),</span> <span class="n">over_years</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">year</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">wi</span><span class="p">(</span><span class="mi">1963</span><span class="p">,</span> <span class="mi">1968</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(4), latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean time(4): mean within years time(4): mean over years</span>
<span class="go">Dimension coords: time(4) = [1963-01-15 00:00:00, ..., 1963-10-16 12:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">datetime_array</span><span class="p">)</span>
<span class="go">[[cftime.DatetimeGregorian(1962-12-01 00:00:00) cftime.DatetimeGregorian(1968-03-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1963-03-01 00:00:00) cftime.DatetimeGregorian(1968-06-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1963-06-01 00:00:00) cftime.DatetimeGregorian(1968-09-01 00:00:00)]</span>
<span class="go"> [cftime.DatetimeGregorian(1963-09-01 00:00:00) cftime.DatetimeGregorian(1968-12-01 00:00:00)]]</span>
</pre></div>
</div>
</div>
<p>Similarly for collapses over days, it is assumed by default that the
each portion of the diurnal cycle is collapsed over all days that are
present, But it is possible to restrict the days to be included, or
group them into chunks, with the <em>over_days</em> keyword to
<a class="reference internal" href="method/cf.Field.collapse.html#cf.Field.collapse" title="cf.Field.collapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">collapse</span></code></a>.</p>
<p>The calculation can be done with multiple collapse calls, which can be
useful if the interim stages are needed independently, but be aware
that the interim field constructs will have non-CF-compliant cell
method constructs.</p>
<div class="literal-block-wrapper docutils container" id="id48">
<div class="code-block-caption"><span class="caption-text"><em>Calculate the multiannual maximum of the seasonal
standard deviations with two separate collapse calls.</em></span><a class="headerlink" href="#id48" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;T: standard_deviation within years&#39;</span><span class="p">,</span>
<span class="gp">... </span>               <span class="n">within_years</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">seasons</span><span class="p">(),</span> <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(40), latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean time(40): standard_deviation within years</span>
<span class="go">Dimension coords: time(40) = [1960-01-15 12:00:00, ..., 1969-10-16 12:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;T: maximum over years&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(4), latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean time(4): standard_deviation within years time(4): maximum over years</span>
<span class="go">Dimension coords: time(4) = [1960-01-15 12:00:00, ..., 1960-10-16 12:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
</section>
</section>
<section id="other-statistical-operations">
<h2><a class="toc-backref" href="#id92"><strong>Other statistical operations</strong></a><a class="headerlink" href="#other-statistical-operations" title="Permalink to this headline">¶</a></h2>
<section id="cumulative-sums">
<span id="id10"></span><h3><a class="toc-backref" href="#id93">Cumulative sums</a><a class="headerlink" href="#cumulative-sums" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="method/cf.Field.cumsum.html#cf.Field.cumsum" title="cf.Field.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code></a> method of the field construct calculates the
cumulative sum of elements along a given axis. The cell bounds of the
axis are updated to describe the ranges over which the sums apply, and
a new <code class="docutils literal notranslate"><span class="pre">sum</span></code> cell method construct is added to the resulting field
construct.</p>
<div class="literal-block-wrapper docutils container" id="id49">
<div class="code-block-caption"><span class="caption-text"><em>Calculate cumulative sums along the “T” axis, showing
the cell bounds before and after the operation.</em></span><a class="headerlink" href="#id49" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;timeseries.nc&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(120), latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean</span>
<span class="go">Dimension coords: time(120) = [1959-12-16 12:00:00, ..., 1969-11-16 00:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: air_potential_temperature (ncvar%air_potential_temperature)</span>
<span class="go">------------------------------------------------------------------</span>
<span class="go">Data            : air_potential_temperature(time(120), latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean time(120): sum</span>
<span class="go">Dimension coords: time(120) = [1959-12-16 12:00:00, ..., 1969-11-16 00:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : air_pressure(1) = [850.0] hPa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dtarray</span><span class="p">)</span>
<span class="go">[[cftime.DatetimeGregorian(1969-11-01 00:00:00)</span>
<span class="go">  cftime.DatetimeGregorian(1969-12-01 00:00:00))]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dtarray</span><span class="p">)</span>
<span class="go">[[cftime.DatetimeGregorian(1959-11-01 00:00:00)</span>
<span class="go">  cftime.DatetimeGregorian(1969-12-01 00:00:00))]]</span>
</pre></div>
</div>
</div>
<p>The treatment of missing values can be specified, as well as the
positioning of coordinate values in the summed axis of the returned
field construct.</p>
</section>
<section id="histograms">
<span id="id11"></span><h3><a class="toc-backref" href="#id94">Histograms</a><a class="headerlink" href="#histograms" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="function/cf.histogram.html#cf.histogram" title="cf.histogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.histogram</span></code></a> function is used to record the distribution of a
set of variables in the form of an N-dimensional histogram.</p>
<p>Each dimension of the histogram is defined by a field construct
returned by the <a class="reference internal" href="method/cf.Field.digitize.html#cf.Field.digitize" title="cf.Field.digitize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">digitize</span></code></a> method of a field construct. This
“digitized” field construct defines a sequence of bins and provides
indices to the bins that each value of one of the variables belongs.</p>
<div class="literal-block-wrapper docutils container" id="id50">
<div class="code-block-caption"><span class="caption-text"><em>Create a one-dimensional histogram of a field construct
based on 10 equally-sized bins that exactly span the data
range.</em></span><a class="headerlink" href="#id50" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;file.nc&#39;</span><span class="p">)</span>
<span class="go">Field: specific_humidity (ncvar%q)</span>
<span class="go">----------------------------------</span>
<span class="go">Data            : specific_humidity(latitude(5), longitude(8)) 1</span>
<span class="go">Cell methods    : area: mean</span>
<span class="go">Dimension coords: latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : time(1) = [2019-01-01 00:00:00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0.007 0.034 0.003 0.014 0.018 0.037 0.024 0.029]</span>
<span class="go"> [0.023 0.036 0.045 0.062 0.046 0.073 0.006 0.066]</span>
<span class="go"> [0.11  0.131 0.124 0.146 0.087 0.103 0.057 0.011]</span>
<span class="go"> [0.029 0.059 0.039 0.07  0.058 0.072 0.009 0.017]</span>
<span class="go"> [0.006 0.036 0.019 0.035 0.018 0.037 0.034 0.013]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">return_bins</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
<span class="go">Field: long_name=Bin index to which each &#39;specific_humidity&#39; value belongs (ncvar%q)</span>
<span class="go">------------------------------------------------------------------------------------</span>
<span class="go">Data            : long_name=Bin index to which each &#39;specific_humidity&#39; value belongs(latitude(5), longitude(8))</span>
<span class="go">Cell methods    : area: mean</span>
<span class="go">Dimension coords: latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_eastg</span>
<span class="go">                : time(1) = [2019-01-01 00:00:00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0 2 0 0 1 2 1 1]</span>
<span class="go"> [1 2 2 4 3 4 0 4]</span>
<span class="go"> [7 8 8 9 5 6 3 0]</span>
<span class="go"> [1 3 2 4 3 4 0 0]</span>
<span class="go"> [0 2 1 2 1 2 2 0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bins</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0.003  0.0173]</span>
<span class="go"> [0.0173 0.0316]</span>
<span class="go"> [0.0316 0.0459]</span>
<span class="go"> [0.0459 0.0602]</span>
<span class="go"> [0.0602 0.0745]</span>
<span class="go"> [0.0745 0.0888]</span>
<span class="go"> [0.0888 0.1031]</span>
<span class="go"> [0.1031 0.1174]</span>
<span class="go"> [0.1174 0.1317]</span>
<span class="go"> [0.1317 0.146 ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="go">Field: number_of_observations</span>
<span class="go">-----------------------------</span>
<span class="go">Data            : number_of_observations(specific_humidity(10)) 1</span>
<span class="go">Cell methods    : latitude: longitude: point</span>
<span class="go">Dimension coords: specific_humidity(10) = [10.15, ..., 138.85000000000002] 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[9 7 9 4 5 1 1 1 2 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span><span class="s1">&#39;specific_humidity&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0.003  0.0173]</span>
<span class="go"> [0.0173 0.0316]</span>
<span class="go"> [0.0316 0.0459]</span>
<span class="go"> [0.0459 0.0602]</span>
<span class="go"> [0.0602 0.0745]</span>
<span class="go"> [0.0745 0.0888]</span>
<span class="go"> [0.0888 0.1031]</span>
<span class="go"> [0.1031 0.1174]</span>
<span class="go"> [0.1174 0.1317]</span>
<span class="go"> [0.1317 0.146 ]]</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id51">
<div class="code-block-caption"><span class="caption-text"><em>Create a two-dimensional histogram based on specific
humidity and temperature bins. The temperature bins in
this example are derived from a dummy temperature field
construct with the same shape as the specific humidity
field construct already in use.</em></span><a class="headerlink" href="#id51" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;air_temperature&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">290</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">override_units</span><span class="p">(</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">Field: air_temperature (ncvar%q)</span>
<span class="go">--------------------------------</span>
<span class="go">Data            : air_temperature(latitude(5), longitude(8)) K</span>
<span class="go">Cell methods    : area: mean</span>
<span class="go">Dimension coords: latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : time(1) = [2019-01-01 00:00:00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices_t</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">indices_t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="go">Field: number_of_observations</span>
<span class="go">-----------------------------</span>
<span class="go">Data            : number_of_observations(air_temperature(5), specific_humidity(10)) 1</span>
<span class="go">Cell methods    : latitude: longitude: point</span>
<span class="go">Dimension coords: air_temperature(5) = [281.1054839143287, ..., 313.9741786365939] K</span>
<span class="go">                : specific_humidity(10) = [0.01015, ..., 0.13885] 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[2  1  5  3  2 -- -- -- -- --]</span>
<span class="go"> [1  1  2 --  1 --  1  1 -- --]</span>
<span class="go"> [4  4  2  1  1  1 -- --  1  1]</span>
<span class="go"> [1  1 -- --  1 -- -- --  1 --]</span>
<span class="go"> [1 -- -- -- -- -- -- -- -- --]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">&lt;CF Data(): 40 1&gt;</span>
</pre></div>
</div>
</div>
</section>
<section id="binning-operations">
<span id="id12"></span><h3><a class="toc-backref" href="#id95">Binning operations</a><a class="headerlink" href="#binning-operations" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="method/cf.Field.bin.html#cf.Field.bin" title="cf.Field.bin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bin</span></code></a> method of the field construct groups its data into
bins, where each group is defined by the elements that correspond to
an <a class="reference internal" href="field_analysis.html#histograms"><span class="std std-ref">N-dimensional histogram bin of another set of variables</span></a>, and collapses the elements in each group to a single
representative value. The same <a class="reference internal" href="field_analysis.html#collapse-methods"><span class="std std-ref">collapse methods</span></a> and <a class="reference internal" href="field_analysis.html#collapse-weights"><span class="std std-ref">weighting options</span></a> as
the <a class="reference internal" href="method/cf.Field.collapse.html#cf.Field.collapse" title="cf.Field.collapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">collapse</span></code></a> method are available.</p>
<p>The result of the binning operation is a field construct whose domain
axis and dimension coordinate constructs describe the sizes of the
N-dimensional bins of the other set of variables.</p>
<div class="literal-block-wrapper docutils container" id="id52">
<div class="code-block-caption"><span class="caption-text"><em>Find the range of values that lie in each of bin 10
equally-sized bins of the data itself.</em></span><a class="headerlink" href="#id52" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;file.nc&#39;</span><span class="p">)</span>
<span class="go">Field: specific_humidity (ncvar%q)</span>
<span class="go">----------------------------------</span>
<span class="go">Data            : specific_humidity(latitude(5), longitude(8)) 0.001 1</span>
<span class="go">Cell methods    : area: mean</span>
<span class="go">Dimension coords: latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : time(1) = [2019-01-01 00:00:00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0.007 0.034 0.003 0.014 0.018 0.037 0.024 0.029]</span>
<span class="go"> [0.023 0.036 0.045 0.062 0.046 0.073 0.006 0.066]</span>
<span class="go"> [0.11  0.131 0.124 0.146 0.087 0.103 0.057 0.011]</span>
<span class="go"> [0.029 0.059 0.039 0.07  0.058 0.072 0.009 0.017]</span>
<span class="go"> [0.006 0.036 0.019 0.035 0.018 0.037 0.034 0.013]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">bin</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">,</span> <span class="n">digitized</span><span class="o">=</span><span class="n">indices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: specific_humidity</span>
<span class="go">------------------------</span>
<span class="go">Data            : specific_humidity(specific_humidity(5)) 1</span>
<span class="go">Cell methods    : latitude: longitude: range</span>
<span class="go">Dimension coords: specific_humidity(5) = [0.0173, ..., 0.1317] 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[0.026 0.025 0.025 0.007 0.022]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span><span class="s1">&#39;specific_humidity&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0.003  0.0316]</span>
<span class="go"> [0.0316 0.0602]</span>
<span class="go"> [0.0602 0.0888]</span>
<span class="go"> [0.0888 0.1174]</span>
<span class="go"> [0.1174 0.146 ]]</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id53">
<div class="code-block-caption"><span class="caption-text"><em>Find the area-weighted mean of specific humidity values
that correspond to two-dimensional bins defined by
temperature and pressure values.</em></span><a class="headerlink" href="#id53" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;file2.nc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">Field: air_temperature (ncvar%t)</span>
<span class="go">--------------------------------</span>
<span class="go">Data            : air_temperature(latitude(5), longitude(8)) degreesC</span>
<span class="go">Cell methods    : area: mean</span>
<span class="go">Dimension coords: latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : time(1) = [2019-01-01 00:00:00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">Field: air_pressure (ncvar%p)</span>
<span class="go">-----------------------------</span>
<span class="go">Data            : air_pressure(latitude(5), longitude(8)) hPa</span>
<span class="go">Cell methods    : area: mean</span>
<span class="go">Dimension coords: latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : time(1) = [2019-01-01 00:00:00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_indices</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_indices</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">bin</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">digitized</span><span class="o">=</span><span class="p">[</span><span class="n">t_indices</span><span class="p">,</span> <span class="n">p_indices</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="s1">&#39;area&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: specific_humidity</span>
<span class="go">------------------------</span>
<span class="go">Data            : specific_humidity(air_pressure(6), air_temperature(4)) 1</span>
<span class="go">Cell methods    : latitude: longitude: mean</span>
<span class="go">Dimension coords: air_pressure(6) = [966.6225003326126, ..., 1033.6456080043665] hPa</span>
<span class="go">                : air_temperature(4) = [-12.735821567738295, ..., 9.9702610462581] degreesC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[     --       --       --  0.011  ]</span>
<span class="go"> [0.131    0.0145   0.0345   0.05052]</span>
<span class="go"> [0.05742  0.01727  0.06392  0.0105 ]</span>
<span class="go"> [     --  0.04516  0.05272  0.10194]</span>
<span class="go"> [0.124    0.024    0.059    0.006  ]</span>
<span class="go"> [     --  0.08971       --       --]]</span>
</pre></div>
</div>
</div>
</section>
<section id="percentiles">
<span id="id13"></span><h3><a class="toc-backref" href="#id96">Percentiles</a><a class="headerlink" href="#percentiles" title="Permalink to this headline">¶</a></h3>
<p>Percentiles of the data can be computed along any subset of the axes
with the <a class="reference internal" href="method/cf.Field.percentile.html#cf.Field.percentile" title="cf.Field.percentile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">percentile</span></code></a> method of the field construct.</p>
<div class="literal-block-wrapper docutils container" id="id54">
<div class="code-block-caption"><span class="caption-text"><em>Find the 20th, 40th, 50th, 60th and 80th percentiles.</em></span><a class="headerlink" href="#id54" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;file.nc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="go">Field: specific_humidity</span>
<span class="go">------------------------</span>
<span class="go">Data            : specific_humidity(latitude(5), longitude(8)) 1</span>
<span class="go">Cell methods    : area: mean</span>
<span class="go">Dimension coords: time(1) = [2019-01-01 00:00:00]</span>
<span class="go">                : latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0.007 0.034 0.003 0.014 0.018 0.037 0.024 0.029]</span>
<span class="go"> [0.023 0.036 0.045 0.062 0.046 0.073 0.006 0.066]</span>
<span class="go"> [0.11  0.131 0.124 0.146 0.087 0.103 0.057 0.011]</span>
<span class="go"> [0.029 0.059 0.039 0.07  0.058 0.072 0.009 0.017]</span>
<span class="go"> [0.006 0.036 0.019 0.035 0.018 0.037 0.034 0.013]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">percentile</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">80</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">Field: specific_humidity</span>
<span class="go">------------------------</span>
<span class="go">Data            : specific_humidity(long_name=Percentile ranks for latitude, longitude dimensions(5), latitude(1), longitude(1)) 1</span>
<span class="go">Dimension coords: time(1) = [2019-01-01 00:00:00]</span>
<span class="go">                : latitude(1) = [0.0] degrees_north</span>
<span class="go">                : longitude(1) = [180.0] degrees_east</span>
<span class="go">                : long_name=Percentile ranks for latitude, longitude dimensions(5) = [20, ..., 80]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[[0.0164]]</span>
<span class="go"> [[0.032 ]]</span>
<span class="go"> [[0.036 ]]</span>
<span class="go"> [[0.0414]]</span>
<span class="go"> [[0.0704]]]</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id55">
<div class="code-block-caption"><span class="caption-text"><em>Find the standard deviation of the values above the 80th
percentile.</em></span><a class="headerlink" href="#id55" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p80</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="mi">80</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p80</span><span class="p">)</span>
<span class="go">Field: specific_humidity</span>
<span class="go">------------------------</span>
<span class="go">Data            : specific_humidity(latitude(1), longitude(1)) 1</span>
<span class="go">Dimension coords: time(1) = [2019-01-01 00:00:00]</span>
<span class="go">                : latitude(1) = [0.0] degrees_north</span>
<span class="go">                : longitude(1) = [180.0] degrees_east</span>
<span class="go">                : long_name=Percentile ranks for latitude, longitude dimensions(1) = [80]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">q</span><span class="o">&lt;=</span><span class="n">p80</span><span class="p">,</span> <span class="n">cf</span><span class="o">.</span><span class="n">masked</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[  --    --    --    --    --    -- -- --]</span>
<span class="go"> [  --    --    --    --    -- 0.073 -- --]</span>
<span class="go"> [0.11 0.131 0.124 0.146 0.087 0.103 -- --]</span>
<span class="go"> [  --    --    --    --    -- 0.072 -- --]</span>
<span class="go"> [  --    --    --    --    --    -- -- --]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;standard_deviation&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
<span class="go">&lt;CF Data(1, 1): [[0.024609938742357642]] 1&gt;</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id56">
<div class="code-block-caption"><span class="caption-text"><em>Find the mean of the values above the 45th percentile
along the X axis.</em></span><a class="headerlink" href="#id56" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p45</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p45</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0.0189 ]</span>
<span class="go"> [0.04515]</span>
<span class="go"> [0.10405]</span>
<span class="go"> [0.04185]</span>
<span class="go"> [0.02125]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">q</span><span class="o">&lt;=</span><span class="n">p45</span><span class="p">,</span> <span class="n">cf</span><span class="o">.</span><span class="n">masked</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[  -- 0.034    --    --    -- 0.037 0.024 0.029]</span>
<span class="go"> [  --    --    -- 0.062 0.046 0.073    -- 0.066]</span>
<span class="go"> [0.11 0.131 0.124 0.146    --    --    --    --]</span>
<span class="go"> [  -- 0.059    -- 0.07  0.058 0.072    --    --]</span>
<span class="go"> [  -- 0.036    -- 0.035   --  0.037 0.034    --]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="s1">&#39;X: mean&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0.031  ]</span>
<span class="go"> [0.06175]</span>
<span class="go"> [0.12775]</span>
<span class="go"> [0.06475]</span>
<span class="go"> [0.0355 ]]</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id57">
<div class="code-block-caption"><span class="caption-text"><em>Find the histogram bin boundaries associated with given
percentiles, and digitize the data based on these bins.</em></span><a class="headerlink" href="#id57" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bins</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">percentile</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bins</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[0.003  0.0088 0.036  0.1037 0.146 ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">closed_ends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0 1 0 1 1 2 1 1]</span>
<span class="go"> [1 2 2 2 2 2 0 2]</span>
<span class="go"> [3 3 3 3 2 2 2 1]</span>
<span class="go"> [1 2 2 2 2 2 1 1]</span>
<span class="go"> [0 2 1 1 1 2 1 1]]</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
</section>
</section>
<section id="regridding">
<span id="id14"></span><h2><a class="toc-backref" href="#id97"><strong>Regridding</strong></a><a class="headerlink" href="#regridding" title="Permalink to this headline">¶</a></h2>
<p>Regridding, also called remapping or interpolation, is the process of
changing the domain of a field construct whilst preserving the
qualities of the original data.</p>
<p>The field construct has two regridding methods: <a class="reference internal" href="method/cf.Field.regrids.html#cf.Field.regrids" title="cf.Field.regrids"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regrids</span></code></a> for
regridding data between domains with spherical coordinate systems; and
<a class="reference internal" href="method/cf.Field.regridc.html#cf.Field.regridc" title="cf.Field.regridc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regridc</span></code></a> for regridding data between domains with Cartesian
coordinate systems. The interpolation is carried by out using the
<a class="reference external" href="https://earthsystemmodeling.org/esmpy/">ESMF</a> package, a
Python interface to the Earth System Modeling Framework regridding
utility.</p>
<p>As with <a class="reference internal" href="field_analysis.html#statistical-collapses"><span class="std std-ref">statistical collapses</span></a>,
regridding may be applied over a subset of the domain axes, and the
domain axis constructs and coordinate constructs for the non-regridded
dimensions remain the same.</p>
<p><a class="reference internal" href="tutorial.html#domain-ancillaries"><span class="std std-ref">Domain ancillary constructs</span></a> whose data
spans the regridding dimensions are also regridded, but <a class="reference internal" href="tutorial.html#field-ancillaries"><span class="std std-ref">field
ancillary constructs</span></a> whose data spans the
regridding dimensions are removed from the regridded field construct.</p>
<section id="regridding-methods">
<span id="id15"></span><h3><a class="toc-backref" href="#id98">Regridding methods</a><a class="headerlink" href="#regridding-methods" title="Permalink to this headline">¶</a></h3>
<p>The following regridding methods are available (in this table,
“source” and “destination” refer to the domain of the field construct
being regridded, and the domain that it is being regridded to,
respectively):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Linear</p></td>
<td><p>Linear interpolation in the number of
dimensions being regridded.</p>
<p>For two dimensional regridding this is
bilinear interpolation, and for three
dimensional regridding this is trilinear
interpolation.</p>
</td>
</tr>
<tr class="row-odd"><td><p>First-order conservative</p></td>
<td><p>First order conservative interpolation.</p>
<p>Preserve the area integral of the data
across the interpolation from source to
destination. It uses the proportion of
the area of the overlapping source and
destination cells to determine
appropriate weights.</p>
<p>In particular, the weight of a source
cell is the ratio of the area of
intersection of the source and
destination cells to the area of the
whole destination cell.</p>
<p>It does not account for the field
gradient across the source cell, unlike
the <em>second-order</em> conservative method.</p>
</td>
</tr>
<tr class="row-even"><td><p>Second-order conservative</p></td>
<td><p>Second-order conservative
interpolation.</p>
<p>As with first order (see above),
preserves the area integral of the field
between source and destination using a
weighted sum, with weights based on the
proportionate area of intersection.</p>
<p>Unlike <em>first-order</em>, the second-order
method incorporates further terms to take
into consideration the gradient of the
field across the source cell, thereby
typically producing a smoother result of
higher accuracy.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Higher-order patch recovery</p></td>
<td><p>Higher-order patch recovery
interpolation.</p>
<p>A second degree polynomial regridding
method, which uses a least squares
algorithm to calculate the polynomial.</p>
<p>This method gives better derivatives in
the resulting destination data than the
linear method.</p>
</td>
</tr>
<tr class="row-even"><td><p>Nearest neighbour</p></td>
<td><p>Nearest neighbour interpolation for which
each destination point is mapped to the
closest source point, or vice versa.</p>
<p>Useful for extrapolation of categorical
data.</p>
<p>When mapping destination to source
points, a given destination point may
receive input from multiple source
points, but no source point will map to
more than one destination point.</p>
<p>When mapping source to destination
points, a given destination receives
input at most one source point.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="spherical-regridding">
<span id="id16"></span><h3><a class="toc-backref" href="#id99">Spherical regridding</a><a class="headerlink" href="#spherical-regridding" title="Permalink to this headline">¶</a></h3>
<p>Regridding from and to spherical coordinate systems using the
<a class="reference internal" href="method/cf.Field.regrids.html#cf.Field.regrids" title="cf.Field.regrids"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regrids</span></code></a> method is only available for the ‘X’ and ‘Y’ axes
simultaneously. All other axes are unchanged. The calculation of the
regridding weights is based on areas and distances on the surface of
the sphere, rather in <a class="reference internal" href="field_analysis.html#cartesian-regridding"><span class="std std-ref">Euclidean space</span></a>.</p>
<p>The following combinations of spherical source and destination domain
coordinate systems are available to the <a class="reference internal" href="method/cf.Field.regrids.html#cf.Field.regrids" title="cf.Field.regrids"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regrids</span></code></a> method:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Spherical source domain</p></th>
<th class="head"><p>Spherical destination domain</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_latitude_longitude">Latitude-longitude</a></p></td>
<td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_latitude_longitude">Latitude-longitude</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_latitude_longitude">Latitude-longitude</a></p></td>
<td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_rotated_pole">Rotated latitude-longitude</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_latitude_longitude">Latitude-longitude</a></p></td>
<td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#appendix-grid-mappings">Plane projection</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_latitude_longitude">Latitude-longitude</a></p></td>
<td><p><a class="reference external" href="https://doi.org/10.1007%2FBF00211684">Tripolar</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_rotated_pole">Rotated latitude-longitude</a></p></td>
<td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_latitude_longitude">Latitude-longitude</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_rotated_pole">Rotated latitude-longitude</a></p></td>
<td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_rotated_pole">Rotated latitude-longitude</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_rotated_pole">Rotated latitude-longitude</a></p></td>
<td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#appendix-grid-mappings">Plane projection</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_rotated_pole">Rotated latitude-longitude</a></p></td>
<td><p><a class="reference external" href="https://doi.org/10.1007%2FBF00211684">Tripolar</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#appendix-grid-mappings">Plane projection</a></p></td>
<td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_latitude_longitude">Latitude-longitude</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#appendix-grid-mappings">Plane projection</a></p></td>
<td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_rotated_pole">Rotated latitude-longitude</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#appendix-grid-mappings">Plane projection</a></p></td>
<td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#appendix-grid-mappings">Plane projection</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#appendix-grid-mappings">Plane projection</a></p></td>
<td><p><a class="reference external" href="https://doi.org/10.1007%2FBF00211684">Tripolar</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://doi.org/10.1007%2FBF00211684">Tripolar</a></p></td>
<td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_latitude_longitude">Latitude-longitude</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://doi.org/10.1007%2FBF00211684">Tripolar</a></p></td>
<td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#_rotated_pole">Rotated latitude-longitude</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://doi.org/10.1007%2FBF00211684">Tripolar</a></p></td>
<td><p><a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#appendix-grid-mappings">Plane projection</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://doi.org/10.1007%2FBF00211684">Tripolar</a></p></td>
<td><p><a class="reference external" href="https://doi.org/10.1007%2FBF00211684">Tripolar</a></p></td>
</tr>
</tbody>
</table>
<p>The most convenient usage is when the destination domain exists
in another field construct. In this case, all you need to specify is the
field construct having the desired destination domain and the
regridding method to use:</p>
<div class="literal-block-wrapper docutils container" id="id58">
<div class="code-block-caption"><span class="caption-text"><em>Regrid the field construct a conservatively onto a grid
contained in field construct b.</em></span><a class="headerlink" href="#id58" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;air_temperature.nc&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;precipitation_flux.nc&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">Field: air_temperature (ncvar%tas)</span>
<span class="go">----------------------------------</span>
<span class="go">Data            : air_temperature(time(2), latitude(73), longitude(96)) K</span>
<span class="go">Cell methods    : time(2): mean</span>
<span class="go">Dimension coords: time(2) = [1860-01-16 00:00:00, 1860-02-16 00:00:00] 360_day</span>
<span class="go">                : latitude(73) = [-90.0, ..., 90.0] degrees_north</span>
<span class="go">                : longitude(96) = [0.0, ..., 356.25] degrees_east</span>
<span class="go">                : height(1) = [2.0] m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">Field: precipitation_flux (ncvar%tas)</span>
<span class="go">-------------------------------------</span>
<span class="go">Data            : precipitation_flux(time(1), latitude(64), longitude(128)) kg m-2 day-1</span>
<span class="go">Cell methods    : time(1): mean (interval: 1.0 month)</span>
<span class="go">Dimension coords: time(1) = [0450-11-16 00:00:00] noleap</span>
<span class="go">                : latitude(64) = [-87.86380004882812, ..., 87.86380004882812] degrees_north</span>
<span class="go">                : longitude(128) = [0.0, ..., 357.1875] degrees_east</span>
<span class="go">                : height(1) = [2.0] m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">regrids</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;conservative&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">Field: air_temperature (ncvar%tas)</span>
<span class="go">----------------------------------</span>
<span class="go">Data            : air_temperature(time(2), latitude(64), longitude(128)) K</span>
<span class="go">Cell methods    : time(2): mean</span>
<span class="go">Dimension coords: time(2) = [1860-01-16 00:00:00, 1860-02-16 00:00:00] 360_day</span>
<span class="go">                : latitude(64) = [-87.86380004882812, ..., 87.86380004882812] degrees_north</span>
<span class="go">                : longitude(128) = [0.0, ..., 357.1875] degrees_east</span>
<span class="go">                : height(1) = [2.0] m</span>
</pre></div>
</div>
</div>
<p>It is generally not necessary to specify which are the ‘X’ and ‘Y’
axes in the domains of both the source and destination field
constructs, since they will be automatically identified by their
metadata. However, in cases when this is not possible (such as for
tripolar domains) the <em>src_axes</em> or <em>dst_axes</em> keywords of the
<a class="reference internal" href="method/cf.Field.regrids.html#cf.Field.regrids" title="cf.Field.regrids"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regrids</span></code></a> method can be used.</p>
<p>It may be that the required destination domain does not exist in a
field construct. In this case, the latitude and longitudes of the
destination domain may be defined solely by dimension or auxiliary
coordinate constructs.</p>
<div class="literal-block-wrapper docutils container" id="id59">
<div class="code-block-caption"><span class="caption-text"><em>Regrid ‘a’ onto two-dimensional (curvilinear) dimension
coordinates latitude and longitude.</em></span><a class="headerlink" href="#id59" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lat</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">DimensionCoordinate</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">Data</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mf">92.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">),</span> <span class="s1">&#39;degrees_north&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lon</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">DimensionCoordinate</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">Data</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">),</span> <span class="s1">&#39;degrees_east&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">regrids</span><span class="p">({</span><span class="s1">&#39;latitude&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">},</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span>
<span class="go">Field: air_temperature (ncvar%tas)</span>
<span class="go">----------------------------------</span>
<span class="go">Data            : air_temperature(time(2), latitude(73), longitude(72)) K</span>
<span class="go">Cell methods    : time(2): mean</span>
<span class="go">Dimension coords: time(2) = [1860-01-16 00:00:00, 1860-02-16 00:00:00] 360_day</span>
<span class="go">                : latitude(73) = [-90.0, ..., 90.0] degrees_north</span>
<span class="go">                : longitude(72) = [0.0, ..., 355.0] degrees_east</span>
<span class="go">                : height(1) = [2.0] m</span>
</pre></div>
</div>
</div>
<p>A destination domain defined by two-dimensional (curvilinear) latitude
and longitude auxiliary coordinate constructs can also be specified in
a similar manner.</p>
<p>An axis is <a class="reference internal" href="tutorial.html#cyclic-domain-axes"><span class="std std-ref">cyclic</span></a> if cells at both of its
ends are actually geographically adjacent. In spherical regridding,
only the ‘X’ axis has the potential for being cyclic. For example, a
longitude cell spanning 359 to 360 degrees east is proximate to the
cell spanning 0 to 1 degrees east.</p>
<p>When a cyclic dimension can not be automatically detected, such as
when its dimension coordinate construct does not have bounds,
cyclicity may be set with the <em>src_cyclic</em> or <em>dst_cyclic</em> keywords of
the <a class="reference internal" href="method/cf.Field.regrids.html#cf.Field.regrids" title="cf.Field.regrids"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regrids</span></code></a> method.</p>
<p>To find out whether a dimension is cyclic use the <a class="reference internal" href="method/cf.Field.iscyclic.html#cf.Field.iscyclic" title="cf.Field.iscyclic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iscyclic</span></code></a>
method of the field construct, or to manually set its cyclicity use
the <code class="xref py py-obj docutils literal notranslate"><span class="pre">cyclic</span></code> method. If the destination domain has been defined by a
dictionary of dimension coordinate constructs, then cyclicity can be
registered by setting a period of cyclicity with the
<a class="reference internal" href="method/cf.DimensionCoordinate.period.html#cf.DimensionCoordinate.period" title="cf.DimensionCoordinate.period"><code class="xref py py-obj docutils literal notranslate"><span class="pre">period</span></code></a> method of the dimension coordinate
construct.</p>
</section>
<section id="cartesian-regridding">
<span id="id17"></span><h3><a class="toc-backref" href="#id100">Cartesian regridding</a><a class="headerlink" href="#cartesian-regridding" title="Permalink to this headline">¶</a></h3>
<p>Cartesian regridding with the <a class="reference internal" href="method/cf.Field.regridc.html#cf.Field.regridc" title="cf.Field.regridc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regridc</span></code></a> method is very
similar to <a class="reference internal" href="field_analysis.html#spherical-regridding"><span class="std std-ref">spherical regridding</span></a>, except
regridding dimensions are not restricted to the horizontal plane, the
source and destination domains are assumed to be <a class="reference external" href="https://en.wikipedia.org/wiki/Euclidean_space">Euclidian spaces</a> for the purpose of
calculating regridding weights, and all dimensions are assumed to be
non-cyclic by default.</p>
<p>Cartesian regridding can be done in up to three dimensions. It is
often used for regridding along the time dimension. A plane projection
coordinate system can be regridded with Cartesian regridding, which
will produce similar results to using using spherical regridding.</p>
<div class="literal-block-wrapper docutils container" id="id60">
<div class="code-block-caption"><span class="caption-text"><em>Regrid the time axis ‘T’ of field ‘a’ with the linear
method onto the grid specified in the dimension coordinate
time.</em></span><a class="headerlink" href="#id60" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">DimensionCoordinate</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">standard_name</span><span class="o">=</span><span class="s1">&#39;time&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">Data</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>                      <span class="n">units</span><span class="o">=</span><span class="s1">&#39;days since 1860-01-01&#39;</span><span class="p">,</span> <span class="n">calendar</span><span class="o">=</span><span class="s1">&#39;360_day&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span>
<span class="go">&lt;CF DimensionCoordinate: time(60) days since 1860-01-01 360_day&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">regridc</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">},</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
<span class="go">Field: air_temperature (ncvar%tas)</span>
<span class="go">----------------------------------</span>
<span class="go">Data            : air_temperature(time(60), latitude(73), longitude(96)) K</span>
<span class="go">Cell methods    : time(60): mean</span>
<span class="go">Dimension coords: time(60) = [1860-01-01 12:00:00, ..., 1860-02-30 12:00:00] 360_day</span>
<span class="go">                : latitude(73) = [-90.0, ..., 90.0] degrees_north</span>
<span class="go">                : longitude(96) = [0.0, ..., 356.25] degrees_east</span>
<span class="go">                : height(1) = [2.0] m</span>
</pre></div>
</div>
</div>
<p>Note the requirement for the conservative method of contiguous,
non-overlapping bounds on the destination domain:</p>
<div class="literal-block-wrapper docutils container" id="id61">
<div class="code-block-caption"><span class="caption-text"><em>Regrid the time axis ‘T’ of field ‘a’ conservatively
(to first order) onto the grid specified in the dimension
coordinate time.</em></span><a class="headerlink" href="#id61" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">regridc</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">},</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;conservative&#39;</span><span class="p">)</span>  <span class="c1"># Raises Exception</span>
<span class="go">ValueError: Destination coordinates must have contiguous, non-overlapping bounds for conservative regridding.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">create_bounds</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">set_bounds</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">regridc</span><span class="p">({</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">time</span><span class="p">},</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;conservative&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">Field: air_temperature (ncvar%tas)</span>
<span class="go">----------------------------------</span>
<span class="go">Data            : air_temperature(time(60), latitude(73), longitude(96)) K</span>
<span class="go">Cell methods    : time(60): mean</span>
<span class="go">Dimension coords: time(60) = [1860-01-01 12:00:00, ..., 1860-02-30 12:00:00] 360_day</span>
<span class="go">                : latitude(73) = [-90.0, ..., 90.0] degrees_north</span>
<span class="go">                : longitude(96) = [0.0, ..., 356.25] degrees_east</span>
<span class="go">                : height(1) = [2.0] m</span>
</pre></div>
</div>
</div>
<p>Cartesian regridding to the dimension of another field construct is
also possible, similarly to spherical regridding.</p>
</section>
<section id="regridding-masked-data">
<span id="id18"></span><h3><a class="toc-backref" href="#id101">Regridding masked data</a><a class="headerlink" href="#regridding-masked-data" title="Permalink to this headline">¶</a></h3>
<p>The data mask of the source field construct is taken into account,
such that the regridded data will be masked in regions where the
source data is masked. By default the mask of the destination field
construct is not used, but can be taken into account by setting
<em>use_dst_mask</em> keyword to the <a class="reference internal" href="method/cf.Field.regrids.html#cf.Field.regrids" title="cf.Field.regrids"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regrids</span></code></a> or <a class="reference internal" href="method/cf.Field.regridc.html#cf.Field.regridc" title="cf.Field.regridc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regridc</span></code></a>
methods. For example, this is useful when part of the destination
domain is not being used (such as the land portion of an ocean grid).</p>
<p>For conservative regridding, masking is done on cells. Masking a
destination cell means that the cell won’t participate in the
regridding. For all other regridding methods, masking is done on
points. For these methods, masking a destination point means that the
point will not participate in the regridding.</p>
</section>
<section id="vertical-regridding">
<span id="id19"></span><h3><a class="toc-backref" href="#id102">Vertical regridding</a><a class="headerlink" href="#vertical-regridding" title="Permalink to this headline">¶</a></h3>
<p>The only option for regridding along a vertical axis is to use
Cartesian regridding. However, care must be taken to ensure that the
vertical axis is transformed so that it’s coordinate values vary
linearly. For example, to regrid data on one set of vertical pressure
coordinates to another set, the pressure coordinates may first be
transformed into the logarithm of pressure, and then changed back to
pressure coordinates after the regridding operation.</p>
<div class="literal-block-wrapper docutils container" id="id62">
<div class="code-block-caption"><span class="caption-text"><em>Regrid a field construct from one set of pressure levels
to another.</em></span><a class="headerlink" href="#id62" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;vertical.nc&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">Field: eastward_wind (ncvar%ua)</span>
<span class="go">-------------------------------</span>
<span class="go">Data            : eastward_wind(time(3), air_pressure(5), grid_latitude(11), grid_longitude(10)) m s-1</span>
<span class="go">Cell methods    : time(3): mean</span>
<span class="go">Dimension coords: time(3) = [1979-05-01 12:00:00, 1979-05-02 12:00:00, 1979-05-03 12:00:00] gregorian</span>
<span class="go">                : air_pressure(5) = [850.0, ..., 50.0] hPa</span>
<span class="go">                : grid_latitude(11) = [23.32, ..., 18.92] degrees</span>
<span class="go">                : grid_longitude(10) = [-20.54, ..., -16.58] degrees</span>
<span class="go">Auxiliary coords: latitude(grid_latitude(11), grid_longitude(10)) = [[67.12, ..., 66.07]] degrees_north</span>
<span class="go">                : longitude(grid_latitude(11), grid_longitude(10)) = [[-45.98, ..., -31.73]] degrees_east</span>
<span class="go">Coord references: grid_mapping_name:rotated_latitude_longitude</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z_p</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">z_p</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[850. 700. 500. 250.  50.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z_ln_p</span> <span class="o">=</span> <span class="n">z_p</span><span class="o">.</span><span class="n">log</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z_ln_p</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">z_ln_p</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[6.74523635 6.55108034 6.2146081  5.52146092 3.91202301]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">replace_construct</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">z_ln_p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_z_p</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">DimensionCoordinate</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">Data</span><span class="p">([</span><span class="mi">800</span><span class="p">,</span> <span class="mi">705</span><span class="p">,</span> <span class="mi">632</span><span class="p">,</span> <span class="mi">510</span><span class="p">,</span> <span class="mf">320.</span><span class="p">],</span> <span class="s1">&#39;hPa&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_z_ln_p</span> <span class="o">=</span> <span class="n">new_z_p</span><span class="o">.</span><span class="n">log</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_z_ln_p</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">regridc</span><span class="p">({</span><span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="n">new_z_ln_p</span><span class="p">},</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_v</span><span class="o">.</span><span class="n">replace_construct</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">new_z_p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">new_v</span><span class="p">)</span>
<span class="go">Field: eastward_wind (ncvar%ua)</span>
<span class="go">-------------------------------</span>
<span class="go">Data            : eastward_wind(time(3), Z(5), grid_latitude(11), grid_longitude(10)) m s-1</span>
<span class="go">Cell methods    : time(3): mean</span>
<span class="go">Dimension coords: time(3) = [1979-05-01 12:00:00, 1979-05-02 12:00:00, 1979-05-03 12:00:00] gregorian</span>
<span class="go">                : Z(5) = [800.0, ..., 320.0] hPa</span>
<span class="go">                : grid_latitude(11) = [23.32, ..., 18.92] degrees</span>
<span class="go">                : grid_longitude(10) = [-20.54, ..., -16.58] degrees</span>
<span class="go">Auxiliary coords: latitude(grid_latitude(11), grid_longitude(10)) = [[67.12, ..., 66.07]] degrees_north</span>
<span class="go">                : longitude(grid_latitude(11), grid_longitude(10)) = [[-45.98, ..., -31.73]] degrees_east</span>
<span class="go">Coord references: grid_mapping_name:rotated_latitude_longitude</span>
</pre></div>
</div>
</div>
<p>Note that the <a class="reference internal" href="method/cf.Field.replace_construct.html#cf.Field.replace_construct" title="cf.Field.replace_construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace_construct</span></code></a> method of the field construct
is used to easily replace the vertical dimension coordinate construct,
without having to manually match up the corresponding domain axis
construct and construct key.</p>
<hr class="docutils" />
</section>
</section>
<section id="mathematical-operations">
<span id="id20"></span><h2><a class="toc-backref" href="#id103"><strong>Mathematical operations</strong></a><a class="headerlink" href="#mathematical-operations" title="Permalink to this headline">¶</a></h2>
<section id="binary-arithmetical-operations">
<span id="id21"></span><h3><a class="toc-backref" href="#id104">Binary arithmetical operations</a><a class="headerlink" href="#binary-arithmetical-operations" title="Permalink to this headline">¶</a></h3>
<p>A field construct may be arithmetically combined with another field
construct, or any other object that is broadcastable to its data. See
the <a class="reference internal" href="class/cf.Field.html#field-binary-arithmetic"><span class="std std-ref">comprehensive list of available binary operations</span></a>.</p>
<p>When combining with another field construct, its data is actually
combined, but only after being transformed so that it is broadcastable
to the first field construct’s data. This is done by using the
metadata constructs of the two field constructs to create a mapping of
physically compatible dimensions between the fields, and then
<a class="reference internal" href="tutorial.html#manipulating-dimensions"><span class="std std-ref">manipulating the dimensions</span></a> of the
other field construct’s data to ensure that they are broadcastable.</p>
<p>In any case, a field construct may appear as the left or right
operand, and augmented assignments are possible.</p>
<p>Automatic units conversions are also carried out between operands
during operations, and if one operand has no units then the units of
the other are assumed.</p>
<div class="literal-block-wrapper docutils container" id="id63">
<div class="code-block-caption"><span class="caption-text"><em>Apply some binary arithmetic operations to combine the
data for a pair of field constructs.</em></span><a class="headerlink" href="#id63" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;file.nc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">stats</span><span class="p">()</span>
<span class="go">{&#39;min&#39;: &lt;CF Data(): 260.0 K&gt;,</span>
<span class="go"> &#39;mean&#39;: &lt;CF Data(): 269.9244444444445 K&gt;,</span>
<span class="go"> &#39;max&#39;: &lt;CF Data(): 280.0 K&gt;,</span>
<span class="go"> &#39;range&#39;: &lt;CF Data(): 20.0 K&gt;,</span>
<span class="go"> &#39;mid_range&#39;: &lt;CF Data(): 270.0 K&gt;,</span>
<span class="go"> &#39;standard_deviation&#39;: &lt;CF Data(): 5.942452002538104 K&gt;,</span>
<span class="go"> &#39;sample_size&#39;: 90}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">&lt;CF Field: air_temperature(atmosphere_hybrid_height_coordinate(1), grid_latitude(10), grid_longitude(9)) K&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">&lt;CF Data(): 520.0 K&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">&lt;CF Data(): 258.0 K&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">&lt;CF Data(): 262.0 K&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)))</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">&lt;CF Data(): 0.0 K&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">cf</span><span class="o">.</span><span class="n">Data</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">29</span><span class="p">),</span> <span class="s1">&#39;0.1 K&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">&lt;CF Data(): 262.6 K&gt;</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id64">
<div class="code-block-caption"><span class="caption-text"><em>Apply a binary addition operation to apply an offset to
the units and permute the axes of air temperature data
on a field construct. Note the use of augmented
assignment to apply an offset to the units.</em></span><a class="headerlink" href="#id64" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">Units</span> <span class="o">-=</span> <span class="mf">273.15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&lt;CF Field: air_temperature(grid_longitude(1), grid_latitude(10), atmosphere_hybrid_height_coordinate(1)) K @ 273.15&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&lt;CF Field: air_temperature(atmosphere_hybrid_height_coordinate(1), grid_latitude(10), grid_longitude(9)) K&gt;</span>
</pre></div>
</div>
</div>
<p>If the physical nature of the result differs from both operands, then
the “standard_name” and “long_name” properties are removed. This is
the case if the units of the result differ from both operands, or if
they have different standard names.</p>
<div class="literal-block-wrapper docutils container" id="id65">
<div class="code-block-caption"><span class="caption-text"><em>Applying a binary operation where the resultant field construct
has a different physical nature to the two operands. Note the
removal of the ‘standard_name’ property to account for this.</em></span><a class="headerlink" href="#id65" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">identities</span><span class="p">()</span>
<span class="go">[&#39;air_temperature&#39;,</span>
<span class="go"> &#39;Conventions=CF-1.7&#39;,</span>
<span class="go"> &#39;project=research&#39;,</span>
<span class="go"> &#39;units=K&#39;,</span>
<span class="go"> &#39;standard_name=air_temperature&#39;,</span>
<span class="go"> &#39;ncvar%ta&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">cf</span><span class="o">.</span><span class="n">Data</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;m s-1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">identities</span><span class="p">()</span>
<span class="go">[&#39;Conventions=CF-1.7&#39;,</span>
<span class="go"> &#39;project=research&#39;,</span>
<span class="go"> &#39;units=m.s-1.K&#39;,</span>
<span class="go"> &#39;ncvar%ta&#39;]</span>
</pre></div>
</div>
</div>
<p>The <a class="reference internal" href="tutorial.html#domain"><span class="std std-ref">domain</span></a> metadata constructs of the result of a
successful arithmetical operation between two field constructs are
unambiguously well defined: The domain metadata constructs of the
result of a successful operation are copied from the left hand side
(LHS) operand, except when a coordinate construct in the LHS operand
has size 1 and the corresponding coordinate construct in right hand
side (RHS) field construct operand has size greater than 1. In this
case the coordinate construct from the RHS operand is used in the
result, to match up with the data broadcasting that will have occurred
during the operation.</p>
<p id="ambiguous-result">In circumstances when domain metadata constructs in the result can not
be inferred unambiguously then an exception will be raised. For
example, this will be the case if both operands are field constructs
with corresponding coordinate constructs of size greater than 1 <em>and
with different coordinate values</em>. In such circumstances, the field
constructs’ data instances may be operated on directly, bypassing any
checks on the metadata. See
<a class="reference internal" href="field_analysis.html#operating-on-the-field-constructs-data"><span class="std std-ref">Operating on the field constructs’ data</span></a> for more details. <em>(This
will be made easier in a future release with a new function for
combining such field constructs.)</em></p>
<p class="rubric" id="bounds">Bounds</p>
<p>For binary operations involving constructs that have bounds, the
result of binary operation will, by default, only have bounds if both
operands have bounds; and the bounds of the result will be the result
of the same binary operation on bounds objects. This behaviour may
modified by the <a class="reference internal" href="function/cf.bounds_combination_mode.html#cf.bounds_combination_mode" title="cf.bounds_combination_mode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.bounds_combination_mode</span></code></a> function.</p>
<div class="literal-block-wrapper docutils container" id="id66">
<div class="code-block-caption"><span class="caption-text"><em>Demonstrate how bounds are treated in binary
operations.</em></span><a class="headerlink" href="#id66" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">dimension_coordinate</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>
<span class="go">Dimension coordinate: longitude</span>
<span class="go">    standard_name = &#39;longitude&#39;</span>
<span class="go">    units = &#39;degrees_east&#39;</span>
<span class="go">    Data(longitude(8)) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">    Bounds:units = &#39;degrees_east&#39;</span>
<span class="go">    Bounds:Data(longitude(8), 2) = [[0.0, ..., 360.0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>
<span class="go">Dimension coordinate: longitude</span>
<span class="go">    standard_name = &#39;longitude&#39;</span>
<span class="go">    units = &#39;degrees_east&#39;</span>
<span class="go">    Data(8) = [45.0, ..., 675.0] degrees_east</span>
<span class="go">    Bounds:units = &#39;degrees_east&#39;</span>
<span class="go">    Bounds:Data(8, 2) = [[0.0, ..., 720.0]] degrees_east</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">50</span><span class="p">)</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>
<span class="go">Dimension coordinate: longitude</span>
<span class="go">    standard_name = &#39;longitude&#39;</span>
<span class="go">    units = &#39;degrees_east&#39;</span>
<span class="go">    Data(8) = [72.5, ..., 387.5] degrees_east</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">bounds_combination_mode</span><span class="p">(</span><span class="s1">&#39;OR&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">50</span><span class="p">)</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>
<span class="go">Dimension coordinate: longitude</span>
<span class="go">    standard_name = &#39;longitude&#39;</span>
<span class="go">    units = &#39;degrees_east&#39;</span>
<span class="go">    Data(8) = [72.5, ..., 387.5] degrees_east</span>
<span class="go">    Bounds:units = &#39;degrees_east&#39;</span>
<span class="go">    Bounds:Data(8, 2) = [[50.0, ..., 410.0]] degrees_east</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span><span class="o">.</span><span class="n">del_bounds</span><span class="p">()</span>
<span class="go">&lt;CF Bounds: longitude(8, 2) degrees_east&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x2</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>
<span class="go">Dimension coordinate: longitude</span>
<span class="go">    standard_name = &#39;longitude&#39;</span>
<span class="go">    units = &#39;degrees_east&#39;</span>
<span class="go">    Data(8) = [45.0, ..., 675.0] degrees_east</span>
<span class="go">    Bounds:units = &#39;degrees_east&#39;</span>
<span class="go">    Bounds:Data(8, 2) = [[22.5, ..., 697.5]] degrees_east</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cf</span><span class="o">.</span><span class="n">bounds_combination_mode</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
<span class="go">&#39;OR&#39;</span>
</pre></div>
</div>
</div>
<p>The setting of the bounds combination mode may also be set in a
context manager:</p>
<div class="literal-block-wrapper docutils container" id="id67">
<div class="code-block-caption"><span class="caption-text"><em>Set the bounds combination mode in a context manager.</em></span><a class="headerlink" href="#id67" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">cf</span><span class="o">.</span><span class="n">bounds_combination_mode</span><span class="p">(</span><span class="s1">&#39;OR&#39;</span><span class="p">):</span>
<span class="gp">... </span>   <span class="p">(</span><span class="n">x2</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">Dimension coordinate: longitude</span>
<span class="go">    standard_name = &#39;longitude&#39;</span>
<span class="go">    units = &#39;degrees_east&#39;</span>
<span class="go">    Data(8) = [45.0, ..., 675.0] degrees_east</span>
<span class="go">    Bounds:units = &#39;degrees_east&#39;</span>
<span class="go">    Bounds:Data(8, 2) = [[22.5, ..., 697.5]] degrees_east</span>
</pre></div>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Care must be taken when combining a construct with a
<a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v1.23)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a> array or a <a class="reference internal" href="class/cf.Data.html#cf.Data" title="cf.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a> instance, due to the ways in
which both of these objects allow themselves to be
combined with other types:</p>
<ul class="simple">
<li><p>If the construct is on the left hand side (LHS) of the
operation then, as expected, a construct is returned
whose data is the combination of the original
construct’s data and the <a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v1.23)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a> array or <a class="reference internal" href="class/cf.Data.html#cf.Data" title="cf.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a>
instance on the right hand side (RHS).</p></li>
<li><p>If, however, the construct is on the RHS then a <a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v1.23)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a>
array or <a class="reference internal" href="class/cf.Data.html#cf.Data" title="cf.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a> instance (which ever type is on the
LHS) is returned, containing the same data as in the
first case.</p></li>
</ul>
<div class="literal-block-wrapper docutils container" id="id68">
<div class="code-block-caption"><span class="caption-text"><em>A field construct will not be returned if
the left hand operand is a numpy array or a
‘Data’ instance.</em></span><a class="headerlink" href="#id68" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">example_field</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="go">cf.field.Field</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span>
<span class="go">numpy.ndarray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
<span class="go">cf.field.Field</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
<span class="go">numpy.ndarray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">cf</span><span class="o">.</span><span class="n">Data</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="go">cf.field.Field</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">Data</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
<span class="go">cf.data.data.Data</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="unary-operations">
<span id="id22"></span><h3><a class="toc-backref" href="#id105">Unary operations</a><a class="headerlink" href="#unary-operations" title="Permalink to this headline">¶</a></h3>
<p>Python unary operators also work on the field construct’s data,
returning a new field construct with modified data values. See the
<a class="reference internal" href="class/cf.Field.html#field-unary-arithmetic"><span class="std std-ref">comprehensive list of available unary operations</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="id69">
<div class="code-block-caption"><span class="caption-text"><em>Apply some unary operations to a field construct’s data.</em></span><a class="headerlink" href="#id69" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;file.nc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0.007 0.034 0.003 0.014 0.018 0.037 0.024 0.029]</span>
<span class="go"> [0.023 0.036 0.045 0.062 0.046 0.073 0.006 0.066]</span>
<span class="go"> [0.11  0.131 0.124 0.146 0.087 0.103 0.057 0.011]</span>
<span class="go"> [0.029 0.059 0.039 0.07  0.058 0.072 0.009 0.017]</span>
<span class="go"> [0.006 0.036 0.019 0.035 0.018 0.037 0.034 0.013]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="o">-</span><span class="n">q</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[-0.007 -0.034 -0.003 -0.014 -0.018 -0.037 -0.024 -0.029]</span>
<span class="go"> [-0.023 -0.036 -0.045 -0.062 -0.046 -0.073 -0.006 -0.066]</span>
<span class="go"> [-0.11  -0.131 -0.124 -0.146 -0.087 -0.103 -0.057 -0.011]</span>
<span class="go"> [-0.029 -0.059 -0.039 -0.07  -0.058 -0.072 -0.009 -0.017]</span>
<span class="go"> [-0.006 -0.036 -0.019 -0.035 -0.018 -0.037 -0.034 -0.013]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0.007 0.034 0.003 0.014 0.018 0.037 0.024 0.029]</span>
<span class="go"> [0.023 0.036 0.045 0.062 0.046 0.073 0.006 0.066]</span>
<span class="go"> [0.11  0.131 0.124 0.146 0.087 0.103 0.057 0.011]</span>
<span class="go"> [0.029 0.059 0.039 0.07  0.058 0.072 0.009 0.017]</span>
<span class="go"> [0.006 0.036 0.019 0.035 0.018 0.037 0.034 0.013]]</span>
</pre></div>
</div>
</div>
</section>
<section id="relational-operations">
<span id="id23"></span><h3><a class="toc-backref" href="#id106">Relational operations</a><a class="headerlink" href="#relational-operations" title="Permalink to this headline">¶</a></h3>
<p>A field construct may compared with another field construct, or any
other object that is broadcastable to its data. See the
<a class="reference internal" href="class/cf.Field.html#field-comparison"><span class="std std-ref">comprehensive list of available relational operations</span></a>. The result is a field construct with Boolean
data values.</p>
<p>When comparing with another field construct, its data is actually
combined, but only after being transformed so that it is broadcastable
to the first field construct’s data. This is done by using the
metadata constructs of the two field constructs to create a mapping of
physically compatible dimensions between the fields, and then
<a class="reference internal" href="tutorial.html#manipulating-dimensions"><span class="std std-ref">manipulating the dimensions</span></a> of the
other field construct’s data to ensure that they are broadcastable.</p>
<p>In any case, a field construct may appear as the left or right
operand.</p>
<p>Automatic units conversions are also carried out between operands
during operations, and if one operand has no units then the units of
the other are assumed.</p>
<div class="literal-block-wrapper docutils container" id="id70">
<div class="code-block-caption"><span class="caption-text"><em>Produce field constructs of Boolean data encapsulating
the nature of some relations between a field construct and
another operand.</em></span><a class="headerlink" href="#id70" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;file.nc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0.007 0.034 0.003 0.014 0.018 0.037 0.024 0.029]</span>
<span class="go"> [0.023 0.036 0.045 0.062 0.046 0.073 0.006 0.066]</span>
<span class="go"> [0.11  0.131 0.124 0.146 0.087 0.103 0.057 0.011]</span>
<span class="go"> [0.029 0.059 0.039 0.07  0.058 0.072 0.009 0.017]</span>
<span class="go"> [0.006 0.036 0.019 0.035 0.018 0.037 0.034 0.013]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">q</span> <span class="o">==</span> <span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[ True  True  True  True  True  True  True  True]</span>
<span class="go"> [ True  True  True  True  True  True  True  True]</span>
<span class="go"> [ True  True  True  True  True  True  True  True]</span>
<span class="go"> [ True  True  True  True  True  True  True  True]</span>
<span class="go"> [ True  True  True  True  True  True  True  True]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">q</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">)</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[ True  True  True  True  True  True  True  True]</span>
<span class="go"> [ True  True  True False  True False  True False]</span>
<span class="go"> [False False False False False False False  True]</span>
<span class="go"> [ True False  True False False False  True  True]</span>
<span class="go"> [ True  True  True  True  True  True  True  True]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">((</span><span class="n">q</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[ True  True  True  True  True  True  True  True]</span>
<span class="go"> [ True  True  True  True  True  True False  True]</span>
<span class="go"> [ True  True  True  True  True  True  True False]</span>
<span class="go"> [ True  True  True  True  True  True False False]</span>
<span class="go"> [False  True  True  True  True  True  True False]]</span>
</pre></div>
</div>
</div>
<p>The “standard_name” and “long_name” properties are removed from the
result, which also has no units.</p>
<div class="literal-block-wrapper docutils container" id="id71">
<div class="code-block-caption"><span class="caption-text"><em>A field construct of Boolean data created from a relational
operation on a field construct and another operand will be
stripped of its standard_name property (and its long_name
property if it has been set, unlike for ‘q’ here).</em></span><a class="headerlink" href="#id71" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">identities</span><span class="p">()</span>
<span class="go">[&#39;specific_humidity&#39;,</span>
<span class="go"> &#39;Conventions=CF-1.7&#39;,</span>
<span class="go"> &#39;project=research&#39;,</span>
<span class="go"> &#39;units=1&#39;,</span>
<span class="go"> &#39;standard_name=specific_humidity&#39;,</span>
<span class="go"> &#39;ncvar%q&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">q</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">identities</span><span class="p">()</span>
<span class="go">[&#39;Conventions=CF-1.7&#39;,</span>
<span class="go"> &#39;project=research&#39;,</span>
<span class="go"> &#39;units=&#39;,</span>
<span class="go"> &#39;ncvar%q&#39;]</span>
</pre></div>
</div>
</div>
<p>The <a class="reference internal" href="tutorial.html#domain"><span class="std std-ref">domain</span></a> metadata constructs of the result of a
successful relational operation between two field constructs are
unambiguously well defined: The domain metadata constructs of the
result of a successful operation are copied from the left hand side
(LHS) operand, except when a coordinate construct in the LHS operand
has size 1 and the corresponding coordinate construct in right hand
side (RHS) field construct operand has size greater than 1. In this
case the coordinate construct from the RHS operand is used in the
result, to match up with the data broadcasting that will have occurred
during the operation.</p>
<p>In circumstances when domain metadata constructs in the result can not
be inferred unambiguously then an exception will be raised. For
example, this will be the case if both operands are field constructs
with corresponding coordinate constructs of size greater than 1 <em>and
with different coordinate values</em>. In such circumstances, the field
constructs’ data instances may be operated on directly, bypassing any
checks on the metadata. See <a class="reference internal" href="field_analysis.html#operating-on-the-field-constructs-data"><span class="std std-ref">Operating on the field constructs’ data</span></a>
for more details. <em>(This will be made easier in a future release with
a new function for combining such field constructs.)</em></p>
</section>
<section id="arithmetical-and-relational-operations-with-insufficient-metadata">
<span id="id24"></span><h3><a class="toc-backref" href="#id107">Arithmetical and relational operations with insufficient metadata</a><a class="headerlink" href="#arithmetical-and-relational-operations-with-insufficient-metadata" title="Permalink to this headline">¶</a></h3>
<p>When both operands of a <a class="reference internal" href="field_analysis.html#binary-arithmetical-operations"><span class="std std-ref">binary arithmetical</span></a> or <a class="reference internal" href="field_analysis.html#relational-operations"><span class="std std-ref">relational</span></a> operation are field constructs then the
creation of the mapping of physically compatible dimensions relies on
there being sufficient metadata. By default, the mapping relies on
their being “strict” identities for the metadata constructs with
multi-valued data. The strict identity is restricted <code class="xref py py-obj docutils literal notranslate"><span class="pre">standard_name</span></code>
property (or <code class="xref py py-obj docutils literal notranslate"><span class="pre">id</span></code> attribute), and may be returned by the <code class="xref py py-obj docutils literal notranslate"><span class="pre">identity</span></code>
method of a construct:</p>
<div class="literal-block-wrapper docutils container" id="id72">
<div class="code-block-caption"><span class="caption-text"><em>Find the “strict” identity of a construct.</em></span><a class="headerlink" href="#id72" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;latitude&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">y</span><span class="o">.</span><span class="n">standard_name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;&#39;</span>
</pre></div>
</div>
</div>
<p>If there is insufficient metadata to create a mapping of physically
compatible dimensions, then there are various techniques that allow
the operation to proceed:</p>
<ul class="simple">
<li><p><strong>Option 1:</strong> The operation may applied to the field constructs’
data instances instead. See
<a class="reference internal" href="field_analysis.html#operating-on-the-field-constructs-data"><span class="std std-ref">Operating on the field constructs’ data</span></a> for more details.</p></li>
<li><p><strong>Option 2:</strong> If the mapping is not possible due to the absence of
<code class="xref py py-obj docutils literal notranslate"><span class="pre">standard_name</span></code> properties (or <code class="xref py py-obj docutils literal notranslate"><span class="pre">id</span></code> attributes) on metadata
constructs that are known to correspond, then setting “relaxed
identities” with the <a class="reference internal" href="function/cf.relaxed_identities.html#cf.relaxed_identities" title="cf.relaxed_identities"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.relaxed_identities</span></code></a> function may
help. Setting relaxed identities to <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.10)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code></a> allows the <code class="xref py py-obj docutils literal notranslate"><span class="pre">long_name</span></code>
property and netCDF variable name (see the <a class="reference internal" href="tutorial.html#netcdf-interface"><span class="std std-ref">netCDF interface</span></a>), to also be considered when identifying
constructs.</p></li>
<li><p><strong>Option 3:</strong> Add more metadata to the field and metadata constructs.</p></li>
</ul>
</section>
<section id="operating-on-the-field-constructs-data">
<span id="id25"></span><h3><a class="toc-backref" href="#id108">Operating on the field constructs’ data</a><a class="headerlink" href="#operating-on-the-field-constructs-data" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="field_analysis.html#binary-arithmetical-operations"><span class="std std-ref">Binary arithmetical</span></a> and
<a class="reference internal" href="field_analysis.html#relational-operations"><span class="std std-ref">relational</span></a> operations between may also
be carried out on their data instances, thereby bypassing any
reference to, or checks on, the metadata constructs. This can be
useful if there <a class="reference internal" href="field_analysis.html#arithmetical-and-relational-operations-with-insufficient-metadata"><span class="std std-ref">insufficient metadata</span></a>
for determining if the two field constructs are compatible; or if the
domain metadata constructs of the result can not be
<a class="reference internal" href="field_analysis.html#ambiguous-result"><span class="std std-ref">unambiguously defined</span></a>.</p>
<p>In such cases the data instances may be operated on instead and the
result then inserted into one of the field constructs, either with the
<a class="reference internal" href="method/cf.Field.set_data.html#cf.Field.set_data" title="cf.Field.set_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_data</span></code></a> method of the field construct, or with
<a class="reference internal" href="tutorial.html#assignment-by-index"><span class="std std-ref">indexed assignment</span></a>. The former technique
is faster and more memory efficient, but the latter technique allows
broadcasting. Alternatively, for augmented assignments, the field
construct data may be changed in-place.</p>
<p>It is up to the user to ensure that the data instances are consistent
in terms of size 1 dimensions (to satisfy the <a class="reference external" href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">numpy broadcasting
rules</a>), dimension order and dimension direction, and that the
resulting data is compatible with the metadata of the field construct
which will contain it. Automatic units conversions are, however, still
accounted for when combining the data instances.</p>
<div class="literal-block-wrapper docutils container" id="id73">
<div class="code-block-caption"><span class="caption-text"><em>Operate on the data and use ‘set_data’ to put the
resulting data into the new field construct.</em></span><a class="headerlink" href="#id73" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">&lt;CF Data(): 260.0 K&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_data</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">&lt;CF Field: air_temperature(atmosphere_hybrid_height_coordinate(1), grid_latitude(10), grid_longitude(9)) K&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">&lt;CF Data(): 0.0 K&gt;</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id74">
<div class="code-block-caption"><span class="caption-text"><em>Update the data with indexed assignment</em></span><a class="headerlink" href="#id74" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span> <span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data</span>
 <span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
 <span class="o">&lt;</span><span class="n">CF</span> <span class="n">Data</span><span class="p">():</span> <span class="mf">0.0</span> <span class="n">K</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id75">
<div class="code-block-caption"><span class="caption-text"><em>An example of augmented assignment involving the data of
two field constructs.</em></span><a class="headerlink" href="#id75" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">data</span> <span class="o">-=</span> <span class="n">t</span><span class="o">.</span><span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">&lt;CF Data(): 0.0 K&gt;</span>
</pre></div>
</div>
</div>
</section>
<section id="trigonometrical-and-hyperbolic-functions">
<h3><a class="toc-backref" href="#id109">Trigonometrical and hyperbolic functions</a><a class="headerlink" href="#trigonometrical-and-hyperbolic-functions" title="Permalink to this headline">¶</a></h3>
<p>The field construct and metadata constructs have methods to apply
trigonometric and hyperbolic functions, and their inverses,
element-wise to the data. These preserve the metadata but
change the construct’s units.</p>
<p>The field construct and metadata constructs support the following
trigonometrical methods:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="method/cf.Field.arccos.html#cf.Field.arccos" title="cf.Field.arccos"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arccos</span></code></a></p></td>
<td><p>Take the inverse trigonometric cosine of the data
element-wise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="method/cf.Field.arcsin.html#cf.Field.arcsin" title="cf.Field.arcsin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arcsin</span></code></a></p></td>
<td><p>Take the inverse trigonometric sine of the data
element-wise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="method/cf.Field.arctan.html#cf.Field.arctan" title="cf.Field.arctan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arctan</span></code></a></p></td>
<td><p>Take the inverse trigonometric tangent of the data
element-wise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="method/cf.Field.cos.html#cf.Field.cos" title="cf.Field.cos"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cos</span></code></a></p></td>
<td><p>Take the trigonometric cosine of the data element-wise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="method/cf.Field.sin.html#cf.Field.sin" title="cf.Field.sin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sin</span></code></a></p></td>
<td><p>Take the trigonometric sine of the data element-wise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="method/cf.Field.tan.html#cf.Field.tan" title="cf.Field.tan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tan</span></code></a></p></td>
<td><p>Take the trigonometric tangent of the data element-wise.</p></td>
</tr>
</tbody>
</table>
<p>The field construct and metadata constructs also support the following
hyperbolic methods:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="method/cf.Field.arccosh.html#cf.Field.arccosh" title="cf.Field.arccosh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arccosh</span></code></a></p></td>
<td><p>Take the inverse hyperbolic cosine of the data
element-wise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="method/cf.Field.arcsinh.html#cf.Field.arcsinh" title="cf.Field.arcsinh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arcsinh</span></code></a></p></td>
<td><p>Take the inverse hyperbolic sine of the data
element-wise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="method/cf.Field.arctanh.html#cf.Field.arctanh" title="cf.Field.arctanh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">arctanh</span></code></a></p></td>
<td><p>Take the inverse hyperbolic tangent of the data
element-wise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="method/cf.Field.cosh.html#cf.Field.cosh" title="cf.Field.cosh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cosh</span></code></a></p></td>
<td><p>Take the hyperbolic cosine of the data element-wise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="method/cf.Field.sinh.html#cf.Field.sinh" title="cf.Field.sinh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sinh</span></code></a></p></td>
<td><p>Take the hyperbolic sine of the data element-wise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="method/cf.Field.tanh.html#cf.Field.tanh" title="cf.Field.tanh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tanh</span></code></a></p></td>
<td><p>Take the hyperbolic tangent of the data element-wise.</p></td>
</tr>
</tbody>
</table>
<div class="literal-block-wrapper docutils container" id="id76">
<div class="code-block-caption"><span class="caption-text"><em>Find the sine of each latitude coordinate value.</em></span><a class="headerlink" href="#id76" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;file.nc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lat</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">dimension_coordinate</span><span class="p">(</span><span class="s1">&#39;latitude&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lat</span><span class="o">.</span><span class="n">data</span>
<span class="go">&lt;CF Data(5): [-75.0, ..., 75.0] degrees_north&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin_lat</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">sin</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin_lat</span><span class="o">.</span><span class="n">data</span>
<span class="go">&lt;CF Data(5): [-0.9659258262890683, ..., 0.9659258262890683] 1&gt;</span>
</pre></div>
</div>
</div>
<p>The “standard_name” and “long_name” properties are removed from the
result.</p>
<p>Note that a number of the inverse methods have
<a class="reference external" href="https://mathworld.wolfram.com/InverseTrigonometricFunctions.html">mathematically restricted domains</a> (see also
<a class="reference external" href="https://mathworld.wolfram.com/InverseHyperbolicFunctions.html">here</a>)
and therefore may return
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/constants.html">“invalid” values</a>
(<code class="xref py py-obj docutils literal notranslate"><span class="pre">nan</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">inf</span></code>). When applying these methods to constructs with masked
data, you may prefer to output masked values instead of invalid ones. In
this case, you can use <code class="xref py py-obj docutils literal notranslate"><span class="pre">mask_invalid</span></code> to do the conversion afterwards:</p>
<div class="literal-block-wrapper docutils container" id="id77">
<div class="code-block-caption"><span class="caption-text"><em>Take the `arctanh` of some masked data and then transform
resultant invalid values into masked data values.</em></span><a class="headerlink" href="#id77" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">Data</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">arctanh</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[-- nan inf 0.5493061443340548 --]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">mask_invalid</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[-- -- -- 0.5493061443340548 --]</span>
</pre></div>
</div>
</div>
</section>
<section id="exponential-and-logarithmic-functions">
<h3><a class="toc-backref" href="#id110">Exponential and logarithmic functions</a><a class="headerlink" href="#exponential-and-logarithmic-functions" title="Permalink to this headline">¶</a></h3>
<p>The field construct and metadata constructs have <a class="reference internal" href="method/cf.Field.exp.html#cf.Field.exp" title="cf.Field.exp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exp</span></code></a> and
<a class="reference internal" href="method/cf.Field.log.html#cf.Field.log" title="cf.Field.log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log</span></code></a> methods for applying exponential and logarithmic
functions respectively element-wise to the data, preserving the
metadata but changing the construct’s units where required.</p>
<div class="literal-block-wrapper docutils container" id="id78">
<div class="code-block-caption"><span class="caption-text"><em>Find the logarithms and exponentials of field constructs.</em></span><a class="headerlink" href="#id78" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span>
<span class="go">&lt;CF Field: specific_humidity(latitude(5), longitude(8)) 1&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">log</span><span class="p">()</span>
<span class="go">&lt;CF Field: specific_humidity(latitude(5), longitude(8)) ln(re 1)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">&lt;CF Field: specific_humidity(latitude(5), longitude(8)) 1&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span>
<span class="go">&lt;CF Field: air_temperature(atmosphere_hybrid_height_coordinate(1), grid_latitude(10), grid_longitude(9)) K&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&lt;CF Field: air_temperature(atmosphere_hybrid_height_coordinate(1), grid_latitude(10), grid_longitude(9)) lg(re 1 K)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>  <span class="c1"># Raises Exception</span>
<span class="go">ValueError: Can&#39;t take exponential of dimensional quantities: &lt;Units: K&gt;</span>
</pre></div>
</div>
</div>
<p>The “standard_name” and “long_name” properties are removed from the
result.</p>
</section>
<section id="rounding-and-truncation">
<h3><a class="toc-backref" href="#id111">Rounding and truncation</a><a class="headerlink" href="#rounding-and-truncation" title="Permalink to this headline">¶</a></h3>
<p>The field construct and metadata constructs the following methods to
round and truncate their data:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="method/cf.Field.ceil.html#cf.Field.ceil" title="cf.Field.ceil"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ceil</span></code></a></p></td>
<td><p>The ceiling of the data, element-wise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="method/cf.Field.clip.html#cf.Field.clip" title="cf.Field.clip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip</span></code></a></p></td>
<td><p>Limit the values in the data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="method/cf.Field.floor.html#cf.Field.floor" title="cf.Field.floor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code></a></p></td>
<td><p>Floor the data array, element-wise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="method/cf.Field.rint.html#cf.Field.rint" title="cf.Field.rint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rint</span></code></a></p></td>
<td><p>Round the data to the nearest integer, element-wise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="method/cf.Field.round.html#cf.Field.round" title="cf.Field.round"><code class="xref py py-obj docutils literal notranslate"><span class="pre">round</span></code></a></p></td>
<td><p>Round the data to the given number of decimals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="method/cf.Field.trunc.html#cf.Field.trunc" title="cf.Field.trunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trunc</span></code></a></p></td>
<td><p>Truncate the data, element-wise.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="moving-windows">
<h3><a class="toc-backref" href="#id112">Moving windows</a><a class="headerlink" href="#moving-windows" title="Permalink to this headline">¶</a></h3>
<p>Moving window calculations along an axis may be created with the
<a class="reference internal" href="method/cf.Field.moving_window.html#cf.Field.moving_window" title="cf.Field.moving_window"><code class="xref py py-obj docutils literal notranslate"><span class="pre">moving_window</span></code></a> method of the field construct.</p>
<p>Moving mean, sum, and integral calculations are possible.</p>
<p>By default moving means are unweighted, but weights based on the axis
cell sizes (or custom weights) may applied to the calculation.</p>
<div class="literal-block-wrapper docutils container" id="id79">
<div class="code-block-caption"><span class="caption-text"><em>Calculate a 3-point weighted mean of the ‘X’ axis. Since
the the ‘X’ axis is cyclic, the mean wraps by default.</em></span><a class="headerlink" href="#id79" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;file.nc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="go">Field: specific_humidity (ncvar%q)</span>
<span class="go">----------------------------------</span>
<span class="go">Data            : specific_humidity(latitude(5), longitude(8)) 1</span>
<span class="go">Cell methods    : area: mean</span>
<span class="go">Dimension coords: latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : time(1) = [2019-01-01 00:00:00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0.007 0.034 0.003 0.014 0.018 0.037 0.024 0.029]</span>
<span class="go"> [0.023 0.036 0.045 0.062 0.046 0.073 0.006 0.066]</span>
<span class="go"> [0.11  0.131 0.124 0.146 0.087 0.103 0.057 0.011]</span>
<span class="go"> [0.029 0.059 0.039 0.07  0.058 0.072 0.009 0.017]</span>
<span class="go"> [0.006 0.036 0.019 0.035 0.018 0.037 0.034 0.013]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[  0.  45.]</span>
<span class="go"> [ 45.  90.]</span>
<span class="go"> [ 90. 135.]</span>
<span class="go"> [135. 180.]</span>
<span class="go"> [180. 225.]</span>
<span class="go"> [225. 270.]</span>
<span class="go"> [270. 315.]</span>
<span class="go"> [315. 360.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">iscyclic</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">moving_window</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">Field: specific_humidity (ncvar%q)</span>
<span class="go">----------------------------------</span>
<span class="go">Data            : specific_humidity(latitude(5), longitude(8)) 1</span>
<span class="go">Cell methods    : area: mean longitude(8): mean</span>
<span class="go">Dimension coords: latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : time(1) = [2019-01-01 00:00:00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[0.02333 0.01467 0.017   0.01167 0.023   0.02633 0.03    0.02   ]</span>
<span class="go"> [0.04167 0.03467 0.04767 0.051   0.06033 0.04167 0.04833 0.03167]</span>
<span class="go"> [0.084   0.12167 0.13367 0.119   0.112   0.08233 0.057   0.05933]</span>
<span class="go"> [0.035   0.04233 0.056   0.05567 0.06667 0.04633 0.03267 0.01833]</span>
<span class="go"> [0.01833 0.02033 0.03    0.024   0.03    0.02967 0.028   0.01767]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[-45.  90.]</span>
<span class="go"> [  0. 135.]</span>
<span class="go"> [ 45. 180.]</span>
<span class="go"> [ 90. 225.]</span>
<span class="go"> [135. 270.]</span>
<span class="go"> [180. 315.]</span>
<span class="go"> [225. 360.]</span>
<span class="go"> [270. 360.]]</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="method/cf.Field.moving_window.html#cf.Field.moving_window" title="cf.Field.moving_window"><code class="xref py py-obj docutils literal notranslate"><span class="pre">moving_window</span></code></a> method can not, in general, be
emulated by the <a class="reference internal" href="method/cf.Field.convolution_filter.html#cf.Field.convolution_filter" title="cf.Field.convolution_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolution_filter</span></code></a> method, as the
latter i) can not change the window weights as the filter
passes through the axis; and ii) does not update the cell
method constructs.</p>
</div>
</section>
<section id="convolution-filters">
<h3><a class="toc-backref" href="#id113">Convolution filters</a><a class="headerlink" href="#convolution-filters" title="Permalink to this headline">¶</a></h3>
<p>A <a class="reference external" href="https://en.wikipedia.org/wiki/Convolution">convolution</a> of the
field construct data with a filter along a single domain axis can be
calculated, which also updates the bounds of a relevant dimension
coordinate construct to account for the width of the
filter. Convolution filters are carried with the
<a class="reference internal" href="method/cf.Field.convolution_filter.html#cf.Field.convolution_filter" title="cf.Field.convolution_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolution_filter</span></code></a> method of the field construct.</p>
<div class="literal-block-wrapper docutils container" id="id80">
<div class="code-block-caption"><span class="caption-text"><em>Calculate a 5-point mean of the ‘X’ axis with a
non-uniform window function. Since the the ‘X’ axis is
cyclic, the convolution wraps by default.</em></span><a class="headerlink" href="#id80" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="go">Field: specific_humidity (ncvar%q)</span>
<span class="go">----------------------------------</span>
<span class="go">Data            : specific_humidity(latitude(5), longitude(8)) 1</span>
<span class="go">Cell methods    : area: mean</span>
<span class="go">Dimension coords: latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : time(1) = [2019-01-01 00:00:00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">iscyclic</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">convolution_filter</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="go">Field: specific_humidity (ncvar%q)</span>
<span class="go">----------------------------------</span>
<span class="go">Data            : specific_humidity(latitude(5), longitude(8)) 1</span>
<span class="go">Cell methods    : area: mean</span>
<span class="go">Dimension coords: latitude(5) = [-75.0, ..., 75.0] degrees_north</span>
<span class="go">                : longitude(8) = [22.5, ..., 337.5] degrees_east</span>
<span class="go">                : time(1) = [2019-01-01 00:00:00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">dimension_coordinate</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[  0.  45.]</span>
<span class="go"> [ 45.  90.]</span>
<span class="go"> [ 90. 135.]</span>
<span class="go"> [135. 180.]</span>
<span class="go"> [180. 225.]</span>
<span class="go"> [225. 270.]</span>
<span class="go"> [270. 315.]</span>
<span class="go"> [315. 360.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">dimension_coordinate</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[-90. 135.]</span>
<span class="go"> [-45. 180.]</span>
<span class="go"> [  0. 225.]</span>
<span class="go"> [ 45. 270.]</span>
<span class="go"> [ 90. 315.]</span>
<span class="go"> [135. 360.]</span>
<span class="go"> [180. 405.]</span>
<span class="go"> [225. 450.]]</span>
</pre></div>
</div>
</div>
<p>The <a class="reference internal" href="method/cf.Field.convolution_filter.html#cf.Field.convolution_filter" title="cf.Field.convolution_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolution_filter</span></code></a> method of the field construct also has
options to</p>
<ul class="simple">
<li><p>Specify how the input array is extended when the filter overlaps a
border, and</p></li>
<li><p>Control the placement position of the filter window.</p></li>
</ul>
<p>Note that the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows" title="(in SciPy v1.8.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal.windows</span></code></a> package has suite of window
functions for creating window weights for filtering:</p>
<div class="literal-block-wrapper docutils container" id="id81">
<div class="code-block-caption"><span class="caption-text"><em>Calculate a 3-point exponential filter of the ‘Y’
axis. Since the ‘Y’ axis is not cyclic, the convolution
by default inserts missing data at points for which the
filter window extends beyond the array.</em></span><a class="headerlink" href="#id81" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">windows</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exponential_window</span> <span class="o">=</span> <span class="n">windows</span><span class="o">.</span><span class="n">exponential</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">exponential_window</span><span class="p">)</span>
<span class="go">[0.36787944 1.         0.36787944]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">convolution_filter</span><span class="p">(</span><span class="n">exponential_window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[--      --      --      --      --      --      --      --     ]</span>
<span class="go"> [0.06604 0.0967  0.09172 0.12086 0.08463 0.1245  0.0358  0.08072]</span>
<span class="go"> [0.12913 0.16595 0.1549  0.19456 0.12526 0.15634 0.06252 0.04153]</span>
<span class="go"> [0.07167 0.12044 0.09161 0.13659 0.09663 0.1235  0.04248 0.02583]</span>
<span class="go"> [--      --      --      --      --      --      --      --     ]]</span>
</pre></div>
</div>
</div>
<p>The magnitude of the integral of the filter (i.e. the sum of the
window weights defined by the <em>window</em> parameter) affects the
convolved values. For example, window weights of <code class="docutils literal notranslate"><span class="pre">[0.2,</span> <span class="pre">0.2</span> <span class="pre">0.2,</span> <span class="pre">0.2,</span>
<span class="pre">0.2]</span></code> will produce a non-weighted 5-point running mean; and window
weights of <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1]</span></code> will produce a 5-point running
sum. Note that the window weights returned by functions of the
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows" title="(in SciPy v1.8.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal.windows</span></code></a> package do not necessarily sum to 1.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="method/cf.Field.moving_window.html#cf.Field.moving_window" title="cf.Field.moving_window"><code class="xref py py-obj docutils literal notranslate"><span class="pre">moving_window</span></code></a> method can not, in general, be
emulated by the <a class="reference internal" href="method/cf.Field.convolution_filter.html#cf.Field.convolution_filter" title="cf.Field.convolution_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolution_filter</span></code></a> method, as the
latter i) can not change the window weights as the filter
passes through the axis; and ii) does not update the cell
method constructs.</p>
</div>
</section>
<section id="general-first-order-derivative">
<h3><a class="toc-backref" href="#id114">General first order derivative</a><a class="headerlink" href="#general-first-order-derivative" title="Permalink to this headline">¶</a></h3>
<p>The derivative along a dimension of the field construct’s data can be
calculated as a centred finite difference with the <a class="reference internal" href="method/cf.Field.derivative.html#cf.Field.derivative" title="cf.Field.derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivative</span></code></a>
method. If the axis is <a class="reference internal" href="tutorial.html#cyclic-domain-axes"><span class="std std-ref">cyclic</span></a> then the
derivative wraps around by default, otherwise it may be forced to wrap
around; a one-sided difference is calculated at the edges; or missing
data is inserted.</p>
<div class="literal-block-wrapper docutils container" id="id82">
<div class="code-block-caption"><span class="caption-text"><em>Calculate for a field construct’s data the derivative along both
the ‘X’ and ‘Y’ axes, where the former (by default) uses missing
values in the calculation, but the latter has been told to use a
one-sided finite difference at the boundary.</em></span><a class="headerlink" href="#id82" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">one_sided_at_boundary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="gradient-vector">
<h3><a class="toc-backref" href="#id115">Gradient vector</a><a class="headerlink" href="#gradient-vector" title="Permalink to this headline">¶</a></h3>
<p>The horizontal gradient vector of a scalar field may calculated with
the <a class="reference internal" href="method/cf.Field.grad_xy.html#cf.Field.grad_xy" title="cf.Field.grad_xy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grad_xy</span></code></a> method when the field has dimension coordinates
of X and Y, in either Cartesian (e.g. plane projection) or spherical
polar coordinate systems.</p>
<p>The horizontal gradient vector in Cartesian coordinates is given by:</p>
<div class="math notranslate nohighlight">
\[\nabla f(x, y) = \left(
\frac{\partial f}{\partial x},
\frac{\partial f}{\partial y}
\right)\]</div>
<p>The horizontal gradient vector in spherical polar coordinates is given
by:</p>
<div class="math notranslate nohighlight">
\[\nabla f(\theta, \phi) = \left(
\frac{1}{r}
\frac{\partial f}{\partial \theta},
\frac{1}{r \sin\theta}
\frac{\partial f}{\partial \phi}
\right)\]</div>
<p>where <em>r</em> is radial distance to the origin, <span class="math notranslate nohighlight">\(\theta\)</span> is the
polar angle with respect to polar axis, and <span class="math notranslate nohighlight">\(\phi\)</span> is the
azimuthal angle.</p>
<p>See <a class="reference internal" href="method/cf.Field.grad_xy.html#cf.Field.grad_xy" title="cf.Field.grad_xy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.Field.grad_xy</span></code></a> for details and examples.</p>
</section>
<section id="laplacian">
<h3><a class="toc-backref" href="#id116">Laplacian</a><a class="headerlink" href="#laplacian" title="Permalink to this headline">¶</a></h3>
<p>The horizontal Laplacian of a scalar field may be calculated with the
<a class="reference internal" href="method/cf.Field.laplacian_xy.html#cf.Field.laplacian_xy" title="cf.Field.laplacian_xy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">laplacian_xy</span></code></a> method when the field has dimension coordinates
of X and Y, in either Cartesian (e.g. plane projection) or spherical
polar coordinate systems.</p>
<p>The horizontal Laplacian in Cartesian coordinates is given by:</p>
<div class="math notranslate nohighlight">
\[\nabla^2 f(x, y) = \frac{\partial^2 f}{\partial x^2}
+
\frac{\partial^2 f}{\partial y^2}\]</div>
<p>The horizontal Laplacian in spherical polar coordinates is given by:</p>
<div class="math notranslate nohighlight">
\[\nabla^2 f(\theta, \phi) =
\frac{1}{r^2 \sin\theta}
\frac{\partial}{\partial \theta}
\left(
\sin\theta
\frac{\partial f}{\partial \theta}
\right)
+
\frac{1}{r^2 \sin^2\theta}
\frac{\partial^2 f}{\partial \phi^2}\]</div>
<p>where <em>r</em> is radial distance to the origin, <span class="math notranslate nohighlight">\(\theta\)</span> is the
polar angle with respect to polar axis, and <span class="math notranslate nohighlight">\(\phi\)</span> is the
azimuthal angle.</p>
<p>See <a class="reference internal" href="method/cf.Field.laplacian_xy.html#cf.Field.laplacian_xy" title="cf.Field.laplacian_xy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.Field.laplacian_xy</span></code></a> for details and examples.</p>
</section>
<section id="divergence">
<h3><a class="toc-backref" href="#id117">Divergence</a><a class="headerlink" href="#divergence" title="Permalink to this headline">¶</a></h3>
<p>The horizontal divergence may be calculated with the <a class="reference internal" href="function/cf.div_xy.html#cf.div_xy" title="cf.div_xy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.div_xy</span></code></a>
function from orthogonal vector component fields which have dimension
coordinates of X and Y, in either Cartesian (e.g. plane projection) or
spherical polar coordinate systems.</p>
<p>The horizontal divergence of the <span class="math notranslate nohighlight">\((f_x, f_y)\)</span> vector in
Cartesian coordinates is given by:</p>
<div class="math notranslate nohighlight">
\[\nabla \cdot (f_{x}(x,y), f_{y}(x,y)) =
\frac{\partial f_x}{\partial x}
+
\frac{\partial f_y}{\partial y}\]</div>
<p>The horizontal divergence of the <span class="math notranslate nohighlight">\((f_\theta, f_\phi)\)</span> vector in
spherical polar coordinates is given by:</p>
<div class="math notranslate nohighlight">
\[\nabla \cdot (f_\theta(\theta,\phi), f_\phi(\theta,\phi)) =
\frac{1}{r \sin\theta}
\left(
\frac{\partial (f_\theta \sin\theta)}{\partial \theta}
+
\frac{\partial f_\phi}{\partial \phi}
\right)\]</div>
<p>where <em>r</em> is radial distance to the origin, <span class="math notranslate nohighlight">\(\theta\)</span> is the
polar angle with respect to polar axis, and <span class="math notranslate nohighlight">\(\phi\)</span> is the
azimuthal angle.</p>
<p>See <a class="reference internal" href="function/cf.div_xy.html#cf.div_xy" title="cf.div_xy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.div_xy</span></code></a> for details and examples.</p>
</section>
<section id="curl">
<h3><a class="toc-backref" href="#id118">Curl</a><a class="headerlink" href="#curl" title="Permalink to this headline">¶</a></h3>
<p>The horizontal curl may be calculated with the <a class="reference internal" href="function/cf.curl_xy.html#cf.curl_xy" title="cf.curl_xy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.curl_xy</span></code></a> function
from orthogonal vector component fields which have dimension
coordinates of X and Y, in either Cartesian (e.g. plane projection) or
spherical polar coordinate systems.</p>
<p>The horizontal curl of the <span class="math notranslate nohighlight">\((f_x, f_y)\)</span> vector in Cartesian
coordinates is given by:</p>
<div class="math notranslate nohighlight">
\[\nabla \times (f_{x}(x,y), f_{y}(x,y)) =
\frac{\partial f_y}{\partial x}
-
\frac{\partial f_x}{\partial y}\]</div>
<p>The horizontal curl of the <span class="math notranslate nohighlight">\((f_\theta, f_\phi)\)</span> vector in
spherical polar coordinates is given by:</p>
<div class="math notranslate nohighlight">
\[\nabla \times (f_\theta(\theta,\phi), f_\phi(\theta,\phi)) =
\frac{1}{r \sin\theta}
\left(
\frac{\partial (f_\phi \sin\theta)}{\partial \theta}
-
\frac{\partial f_\theta}{\partial \phi}
\right)\]</div>
<p>where <em>r</em> is radial distance to the origin, <span class="math notranslate nohighlight">\(\theta\)</span> is the
polar angle with respect to polar axis, and <span class="math notranslate nohighlight">\(\phi\)</span> is the
azimuthal angle.</p>
<p>See <a class="reference internal" href="function/cf.curl_xy.html#cf.curl_xy" title="cf.curl_xy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.curl_xy</span></code></a> for details and examples.</p>
</section>
<section id="relative-vorticity">
<h3><a class="toc-backref" href="#id119">Relative vorticity</a><a class="headerlink" href="#relative-vorticity" title="Permalink to this headline">¶</a></h3>
<p>The relative vorticity of the wind may be calculated on a global or
limited area domain, and in Cartesian or spherical polar coordinate
systems.</p>
<p>The relative vorticity of wind defined on a Cartesian domain (such as
a <a class="reference external" href="http://cfconventions.org/cf-conventions/cf-conventions.html#appendix-grid-mappings">Plane projection</a>) is defined as</p>
<div class="math notranslate nohighlight">
\[\zeta _{cartesian} = \frac{\delta v}{\delta x} -
\frac{\delta u}{\delta y}\]</div>
<p>where <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are points on along the ‘X’ and ‘Y’
Cartesian dimensions respectively; and <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> denote
the ‘X’ and ‘Y’ components of the horizontal winds.</p>
<p>If the wind field is defined on a spherical latitude-longitude
domain then a correction factor is included:</p>
<div class="math notranslate nohighlight">
\[\zeta _{spherical} = \frac{\delta v}{\delta x} -
\frac{\delta u}{\delta y} + \frac{u}{r}tan(\phi)\]</div>
<p>where <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> denote the longitudinal and latitudinal
components of the horizontal wind field; <span class="math notranslate nohighlight">\(r\)</span> is the radius of
the Earth; and <span class="math notranslate nohighlight">\(\phi\)</span> is the latitude at each point.</p>
<p>The <a class="reference internal" href="function/cf.relative_vorticity.html#cf.relative_vorticity" title="cf.relative_vorticity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.relative_vorticity</span></code></a> function creates a relative vorticity
field construct from field constructs containing the wind components
using finite differences to approximate the derivatives. Dimensions
other than ‘X’ and ‘Y’ remain unchanged by the operation.</p>
<div class="literal-block-wrapper docutils container" id="id83">
<div class="code-block-caption"><span class="caption-text"><em>Generate a relative vorticity field construct from wind
component field constructs, then round the field’s data to
8 decimal places.</em></span><a class="headerlink" href="#id83" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;wind_components.nc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zeta</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">relative_vorticity</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">zeta</span><span class="p">)</span>
<span class="go">Field: atmosphere_relative_vorticity (ncvar%va)</span>
<span class="go">-----------------------------------------------</span>
<span class="go">Data            : atmosphere_relative_vorticity(time(1), atmosphere_hybrid_height_coordinate(1), latitude(9), longitude(8)) s-1</span>
<span class="go">Dimension coords: time(1) = [1978-09-01 06:00:00] 360_day</span>
<span class="go">                : atmosphere_hybrid_height_coordinate(1) = [9.9982] m</span>
<span class="go">                : latitude(9) = [-90, ..., 70] degrees_north</span>
<span class="go">                : longitude(8) = [0, ..., 315] degrees_east</span>
<span class="go">Coord references: standard_name:atmosphere_hybrid_height_coordinate</span>
<span class="go">Domain ancils   : atmosphere_hybrid_height_coordinate(atmosphere_hybrid_height_coordinate(1)) = [9.9982] m</span>
<span class="go">                : long_name=vertical coordinate formula term: b(k)(atmosphere_hybrid_height_coordinate(1)) = [0.9989]</span>
<span class="go">                : surface_altitude(latitude(9), longitude(8)) = [[2816.25, ..., 2325.98]] m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">zeta</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="go">[[[[--        --        --        --        --        --        --        --       ]</span>
<span class="go">   [-2.04e-06  1.58e-06  5.19e-06  4.74e-06 -4.76e-06 -2.27e-06  9.55e-06 -3.64e-06]</span>
<span class="go">   [-8.4e-07  -4.37e-06 -3.55e-06 -2.31e-06 -3.6e-07  -8.58e-06 -2.45e-06  6.5e-07 ]</span>
<span class="go">   [ 4.08e-06  4.55e-06  2.75e-06  4.15e-06  5.16e-06  4.17e-06  4.67e-06 -7e-07   ]</span>
<span class="go">   [-1.4e-07  -3.5e-07  -1.27e-06 -1.29e-06  2.01e-06  4.4e-07  -2.5e-06   2.05e-06]</span>
<span class="go">   [-7.3e-07  -1.59e-06 -1.77e-06 -3.13e-06 -7.9e-07  -5.1e-07  -2.79e-06  1.12e-06]</span>
<span class="go">   [-3.7e-07   7.1e-07   1.52e-06  6.5e-07  -2.75e-06 -4.3e-07   1.62e-06 -6.6e-07 ]</span>
<span class="go">   [ 9.5e-07  -8e-07     6.6e-07   7.2e-07  -2.13e-06 -4.5e-07  -7.5e-07  -1.11e-06]</span>
<span class="go">   [--        --        --        --        --        --        --        --       ]]]]</span>
</pre></div>
</div>
</div>
<p>For axes that are not <a class="reference internal" href="tutorial.html#cyclic-domain-axes"><span class="std std-ref">cyclic</span></a>, missing data
is inserted at the edges by default; otherwise it may be forced to
wrap around, or a one-sided difference is calculated at the edges. If
the longitudinal axis is <a class="reference internal" href="tutorial.html#cyclic-domain-axes"><span class="std std-ref">cyclic</span></a> then the
derivative wraps around by default.</p>
<hr class="docutils" />
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2022, NCAS | Page built on 2022-06-23.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>