
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Performance &#8212; Documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/customise-alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/toggleprompt.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Releases" href="releases.html" />
    <link rel="prev" title="Aggregation rules" href="aggregation_rules.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.svg" alt="Logo"/>
            </a></p>



<h1 class="logo"><a href="index.html">cf 3.15.4</a></h1>



<p class="blurb">A CF-compliant earth science data analysis library</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=NCAS-CMS&repo=cf-python&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html"><strong>Introduction</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="cf_data_model.html"><strong>CF data model</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html"><strong>Installation</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="cheat_sheet.html"><strong>Cheat Sheet</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="recipes/index.html"><strong>Recipes using cf</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html"><strong>Tutorial</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis.html"><strong>Analysis</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="api_reference.html"><strong>API reference</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="aggregation_rules.html"><strong>Aggregation rules</strong></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><strong>Performance</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="releases.html"><strong>Releases</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="Changelog.html"><strong>Change log</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html"><strong>Contributing</strong></a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="aggregation_rules.html" title="previous chapter"><strong>Aggregation rules</strong></a></li>
      <li>Next: <a href="releases.html" title="next chapter"><strong>Releases</strong></a></li>
  </ul></li>
</ul>
</div>

<br>
cf development has been supported by
the <a href="https://erc.europa.eu/">ERC</a>
through <a href="https://cordis.europa.eu/project/id/247220">Seachange</a>
and
<a href="https://cordis.europa.eu/project/id/786427">Couplet</a>; by
the <a href="https://ec.europa.eu/programmes/horizon2020/">EC Horizon
2020 programme</a> through
<a href="https://cordis.europa.eu/project/id/824084">IS-ENES3</a>;
by <a href="https://nerc.ukri.org/">NERC</a> through
<a href="https://gtr.ukri.org/project/0D95A6DB-0B95-48F7-8A8B-7B9A47DEA117">UKFAFMIP</a>;
and by <a href="https://ncas.ac.uk/">NCAS</a>.
<br>
<br>
<img src="_templates/logo_EC.png" height="40">
<img src="_templates/logo_ERC.png" height="40">
<img src="_templates/logo_NERC.png" height="40">
<br>
<img src="_templates/logo_NCAS.png" height="40">
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="performance">
<span id="id1"></span><h1><strong>Performance</strong><a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h1>
<hr class="docutils" />
<p>Version 3.15.4 for version 1.10 of the CF conventions.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#dask" id="id10"><strong>Dask</strong></a></p></li>
<li><p><a class="reference internal" href="#lazy-operations" id="id11"><strong>Lazy operations</strong></a></p></li>
<li><p><a class="reference internal" href="#chunks" id="id12"><strong>Chunks</strong></a></p></li>
<li><p><a class="reference internal" href="#parallel-computation" id="id13"><strong>Parallel computation</strong></a></p>
<ul>
<li><p><a class="reference internal" href="#netcdf-file-access" id="id14">NetCDF file access</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="dask">
<span id="id2"></span><h2><a class="toc-backref" href="#id10"><strong>Dask</strong></a><a class="headerlink" href="#dask" title="Permalink to this headline">¶</a></h2>
<p>A data array in <code class="xref py py-obj docutils literal notranslate"><span class="pre">cf</span></code> is stored internally by a <a class="reference external" href="https://docs.dask.org/en/latest/array.html">Dask array</a> that provides lazy,
parallelised, and out-of-core computations of array
operations. Computations are automatically optimised to maximise the
re-use of data in memory, and to avoid calculations that do not
contribute for the final result.</p>
<p>The performance of <code class="xref py py-obj docutils literal notranslate"><span class="pre">cf</span></code> is largely a function of the performance of
Dask. All of the techniques that Dask supports for <a class="reference external" href="https://docs.dask.org/en/stable/best-practices.html">improving
performance</a>
apply, and performance parameters are generally best set via Dask’s
<a class="reference external" href="https://docs.dask.org/en/stable/configuration.html">configuration settings</a>, but the value
of the important <a class="reference internal" href="#chunks"><span class="std std-ref">chunk size</span></a> is set through the <code class="xref py py-obj docutils literal notranslate"><span class="pre">cf</span></code>
API.</p>
<hr class="docutils" />
</section>
<section id="lazy-operations">
<span id="id3"></span><h2><a class="toc-backref" href="#id11"><strong>Lazy operations</strong></a><a class="headerlink" href="#lazy-operations" title="Permalink to this headline">¶</a></h2>
<p>In general, all <code class="xref py py-obj docutils literal notranslate"><span class="pre">cf</span></code> data operations (such as reading from disk,
regridding, collapsing, subspacing, arithmetic, etc.) are managed by
Dask and so are <a class="reference external" href="https://en.wikipedia.org/wiki/Lazy_evaluation">evaluated lazily</a>, meaning that
operations are not actually performed until the result is actually
inspected by, for instance, creating a plot of the data, writing the
data to disk, printing the array values, etc. When multiple operations
are applied one after another, none of the operations are computed
until the result of the final one is requested.</p>
<p>When the result of a stack of lazy operations is computed it is not
cached, so if the result is requested again then the calculations are
re-computed. However, a construct’s <a class="reference internal" href="method/cf.Field.persist.html#cf.Field.persist" title="cf.Field.persist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">persist</span></code></a> method can be
used to force the result to be retained in memory for fast future
access.</p>
<p>Some notable cases where non-lazy computations occur are:</p>
<ul>
<li><p><strong>Regridding</strong></p>
<p>When regridding a field construct with either of the
<a class="reference internal" href="method/cf.Field.regrids.html#cf.Field.regrids" title="cf.Field.regrids"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.Field.regrids</span></code></a> or <a class="reference internal" href="method/cf.Field.regridc.html#cf.Field.regridc" title="cf.Field.regridc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.Field.regridc</span></code></a> methods, the application of
the regridding operator is a lazy operation but the regridding
operator’s weights are computed non-lazily, which requires
calculations based in some or all of the coordinate data. The
computation of the weights can be much more costly than the
regridding itself. When multiple regrid operations have the same
weights, performance can be greatly improved by calculating the
weights once and re-using them:</p>
<div class="literal-block-wrapper docutils container" id="id6">
<div class="code-block-caption"><span class="caption-text"><em>Regrid a list of fields with the same horizontal
domain using pre-computed regridding weights.</em></span><a class="headerlink" href="#id6" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">fl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">regrids</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;conservative&#39;</span><span class="p">,</span> <span class="n">return_operator</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regridded</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">regrids</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fl</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>The weights may also be stored on disk for re-use in future sessions
by using the <code class="docutils literal notranslate"><span class="pre">weights_file</span></code> keyword parameter.</p>
</li>
<li><p><strong>Aggregation</strong></p>
<p>When two or more field or domain constructs are aggregated to form a
single construct, either by <a class="reference internal" href="function/cf.aggregate.html#cf.aggregate" title="cf.aggregate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.aggregate</span></code></a> or <a class="reference internal" href="function/cf.read.html#cf.read" title="cf.read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.read</span></code></a> (the latter
calls the former by default), the data arrays of some metadata
constructs (coordinates, cell measures, etc.) must be compared
non-lazily to ascertain if aggregation is possible.</p>
</li>
</ul>
<ul>
<li><p><strong>Reading compressed-by-convention datasets from disk</strong></p>
<p>When reading from files datasets that have been compressed by
convention (such as compression by gathering, some discrete sampling
geometries, etc.), the compression metadata, such as the “list”
array for compression by gathering, are read from disk non-lazily
during the <a class="reference internal" href="function/cf.read.html#cf.read" title="cf.read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.read</span></code></a> operation.</p>
</li>
</ul>
<hr class="docutils" />
</section>
<section id="chunks">
<span id="id4"></span><h2><a class="toc-backref" href="#id12"><strong>Chunks</strong></a><a class="headerlink" href="#chunks" title="Permalink to this headline">¶</a></h2>
<p>A Dask array is divided into pieces called “chunks” that are the
elements over which Dask computations can be parallelised, and
performance is strongly dependent on the size and shape of these
chunks.</p>
<p>By default, chunks have a size of at most <code class="docutils literal notranslate"><span class="pre">128</span> <span class="pre">MiB</span></code> and prefer
square-like shapes. A new default chunk size is set with the
<a class="reference internal" href="function/cf.chunksize.html#cf.chunksize" title="cf.chunksize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.chunksize</span></code></a> function. The default chunk size and shape may be
overridden by <a class="reference internal" href="function/cf.read.html#cf.read" title="cf.read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.read</span></code></a>, as well as when creating <a class="reference internal" href="class/cf.Data.html#cf.Data" title="cf.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.Data</span></code></a> instances ab
initio. Any data may be re-chunked after its creation with the
<a class="reference internal" href="method/cf.Data.rechunk.html#cf.Data.rechunk" title="cf.Data.rechunk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.Data.rechunk</span></code></a> method, although this operation can be expensive.</p>
<p>In general, good performance results from following these rules for
chunk sizes and shapes (copied from the <a class="reference external" href="https://docs.dask.org/en/stable/array-chunks.html">Dask chunks documentation</a>):</p>
<ul class="simple">
<li><p>A chunk should be small enough to fit comfortably in memory. There
will be many chunks in memory at once. Dask will often have as
many chunks in memory as twice the number of active threads.</p></li>
<li><p>A chunk must be large enough so that computations on that chunk take
significantly longer than the <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">ms</span></code> overhead per task that
<a class="reference internal" href="#parallel-computation"><span class="std std-ref">Dask scheduling</span></a> incurs. A task should
take longer than <code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">ms</span></code>.</p></li>
<li><p>Chunk sizes between <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">MiB</span></code> and <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">GiB</span></code> are common, depending
on the availability of RAM and the duration of computations.</p></li>
<li><p>Chunks should align with the computation that you want to do. For
example, if you plan to frequently slice along a particular
dimension, then it’s more efficient if your chunks are aligned so
that you have to touch fewer chunks. If you want to add two arrays,
then its convenient if those arrays have matching chunks patterns.</p></li>
<li><p>Chunks should align with your storage, if applicable.</p></li>
</ul>
<p>For more information, see <a class="reference external" href="https://blog.dask.org/2021/11/02/choosing-dask-chunk-sizes">Choosing good chunk sizes in Dask</a>.</p>
<hr class="docutils" />
</section>
<section id="parallel-computation">
<span id="id5"></span><h2><a class="toc-backref" href="#id13"><strong>Parallel computation</strong></a><a class="headerlink" href="#parallel-computation" title="Permalink to this headline">¶</a></h2>
<p>All operations on Dask arrays are executed in parallel using <a class="reference external" href="https://docs.dask.org/en/stable/scheduling.html">Dask’s
dynamic task scheduling</a>. By default, the
scheduler uses threads on the local machine, but can instead use
local processes, a cluster of many machines, or a single
thread with no parallelism at all.</p>
<p>Implementing a different scheduler is done via any of the methods
supported by Dask, and all <code class="xref py py-obj docutils literal notranslate"><span class="pre">cf</span></code> operations executed after a new
scheduler has been defined will use that scheduler.</p>
<div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption"><span class="caption-text"><em>Various techniques for choosing different task
schedulers for parallel computations.</em></span><a class="headerlink" href="#id7" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dask</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">scheduler</span><span class="o">=</span><span class="s1">&#39;processes&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># cf computations will now use local processes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dask</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">scheduler</span><span class="o">=</span><span class="s1">&#39;synchronous&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># cf computations will now be single-threaded</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dask</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">scheduler</span><span class="o">=</span><span class="s1">&#39;threads&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># cf computations will now use local threads (the default)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="s1">&#39;127.0.0.1:8786&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># cf computations will now use the defined distributed cluster</span>
</pre></div>
</div>
</div>
<p>Operations are stored by Dask in <a class="reference external" href="https://docs.dask.org/en/stable/graphs.html">task graphs</a> where each task
(i.e. node) in the graph either defines either a chunk of data, or an
operation to be performed on one or more data chunks. The data created
by an operation are used as inputs to the next operation task in the
graph. The tasks in the graph are passed by the scheduler to the
available pool of processing elements, which execute the tasks in
parallel until the final result has been computed.</p>
<p>The following example creates a visualisation of the task graph for a
basic data computation over four chunks:</p>
<div class="literal-block-wrapper docutils container" id="id8">
<div class="code-block-caption"><span class="caption-text"><em>Visualising the task graph for a lazy computation.</em></span><a class="headerlink" href="#id8" title="Permalink to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">npartitions</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">chunks</span>
<span class="go">((3, 2), (3, 3))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[ 0  1  2  3  4  5]</span>
<span class="go"> [ 6  7  8  9 10 11]</span>
<span class="go"> [12 13 14 15 16 17]</span>
<span class="go"> [18 19 20 21 22 23]</span>
<span class="go"> [24 25 26 27 28 29]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">d</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">to_dask_array</span><span class="p">()</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="s1">&#39;dask_task_graph.png&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">[[  0   2   6  12  20  30]</span>
<span class="go"> [ 42  56  72  90 110 132]</span>
<span class="go"> [156 182 210 240 272 306]</span>
<span class="go"> [342 380 420 462 506 552]</span>
<span class="go"> [600 650 702 756 812 870]]</span>
</pre></div>
</div>
</div>
<p>The image file <code class="docutils literal notranslate"><span class="pre">dask_task_graph.png</span></code> contains the visualisation of
the dask task graph, showing the operations on each chunk. The
operations were only executed when their result was requested with the
final <code class="docutils literal notranslate"><span class="pre">e.array</span></code> command. The boxes represent the data chunks and the
circles represent the operations to be performed on the chunks. The
five boxes in the bottom row are the starting data (i.e. the four
chunks of <code class="docutils literal notranslate"><span class="pre">d</span></code> and the scalar <code class="docutils literal notranslate"><span class="pre">2</span></code>), and the four boxes in the top
row are the result of the computations which combine to produce the
values in <code class="docutils literal notranslate"><span class="pre">e.array</span></code>.</p>
<figure class="align-default" id="id9">
<a class="reference internal image-reference" href="_images/dask_task_graph.svg"><img alt="_images/dask_task_graph.svg" height="478.72" src="_images/dask_task_graph.svg" width="531.2" /></a>
<figcaption>
<p><span class="caption-text"><em>The dask task graph from dask_task_graph.png</em></span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<section id="netcdf-file-access">
<h3><a class="toc-backref" href="#id14">NetCDF file access</a><a class="headerlink" href="#netcdf-file-access" title="Permalink to this headline">¶</a></h3>
<p>Note that reading from and writing to netCDF files is currently a
serial operation, i.e. only one Dask chunk can access any netCDF file
at any given moment. This situation can result in slower-than-expected
performance. When a thread-safe version of the netCDF-C library is
available we hope to lift this restriction.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, NCAS | Page built on 2023-10-10.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>