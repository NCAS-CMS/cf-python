
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>cf.Field.regrids &#8212; Documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/customise-alabaster.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/toggleprompt.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="cf.Field.day" href="../attribute/cf.Field.day.html" />
    <link rel="prev" title="cf.Field.regridc" href="cf.Field.regridc.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">



<h1 class="logo"><a href="../index.html">cf 3.7.0</a></h1>



<p class="blurb">A CF-compliant earth science data analysis library</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=NCAS-CMS&repo=cf-python&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html"><strong>Introduction</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../cf_data_model.html"><strong>CF data model</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html"><strong>Installation</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html"><strong>Contributing</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html"><strong>Tutorial</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../analysis.html"><strong>Analysis</strong></a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api_reference.html"><strong>API reference</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../aggregation_rules.html"><strong>Aggregation rules</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance.html"><strong>Performance</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html"><strong>Releases</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Changelog.html"><strong>Change log</strong></a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../api_reference.html"><strong>API reference</strong></a><ul>
  <li><a href="../class.html"><strong>cf classes</strong></a><ul>
  <li><a href="../class/cf.Field.html">cf.Field</a><ul>
      <li>Previous: <a href="cf.Field.regridc.html" title="previous chapter">cf.Field.regridc</a></li>
      <li>Next: <a href="../attribute/cf.Field.day.html" title="next chapter">cf.Field.day</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="cf-field-regrids">
<h1>cf.Field.regrids<a class="headerlink" href="#cf-field-regrids" title="Permalink to this headline">¶</a></h1>
<dl class="method">
<dt id="cf.Field.regrids">
<code class="sig-prename descclassname">Field.</code><code class="sig-name descname">regrids</code><span class="sig-paren">(</span><em class="sig-param">dst</em>, <em class="sig-param">method</em>, <em class="sig-param">src_cyclic=None</em>, <em class="sig-param">dst_cyclic=None</em>, <em class="sig-param">use_src_mask=True</em>, <em class="sig-param">use_dst_mask=False</em>, <em class="sig-param">fracfield=False</em>, <em class="sig-param">src_axes=None</em>, <em class="sig-param">dst_axes=None</em>, <em class="sig-param">axis_order=None</em>, <em class="sig-param">ignore_degenerate=True</em>, <em class="sig-param">inplace=False</em>, <em class="sig-param">i=False</em>, <em class="sig-param">_compute_field_mass=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/NCAS-CMS/cf-python/blob/v3.7.0/cf/field.py#L18524-L19186"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cf.Field.regrids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the field regridded onto a new latitude-longitude grid.</p>
<p>Regridding, also called remapping or interpolation, is the process
of changing the grid underneath field data values while preserving
the qualities of the original data.</p>
<p>The regridding method must be specified. First-order conservative
interpolation conserves the global area integral of the field, but
may not give approximations to the values as good as linear
interpolation. Second-order conservative interpolation also takes
into account the gradient across the source cells, so in general
gives a smoother, more accurate representation of the source field
especially when going from a coarser to a finer grid. Linear
interpolation is available. The latter method is particular useful
for cases when the latitude and longitude coordinate cell
boundaries are not known nor inferrable. Higher order patch
recovery is available as an alternative to linear
interpolation. This typically results in better approximations to
values and derivatives compared to the latter, but the weight
matrix can be larger than the linear matrix, which can be an
issue when regridding close to the memory limit on a
machine. Nearest neighbour interpolation is also
available. Nearest source to destination is particularly useful
for regridding integer fields such as land use.</p>
<p><strong>Metadata</strong></p>
<p>The field construct’s domain must have well defined X and Y axes
with latitude and longitude coordinate values, which may be stored
as dimension coordinate objects or two dimensional auxiliary
coordinate objects. If the latitude and longitude coordinates are
two dimensional then the X and Y axes must be defined by dimension
coordinates if present or by the netCDF dimensions. In the latter
case the X and Y axes must be specified using the <em>src_axes</em> or
<em>dst_axes</em> keyword. The same is true for the destination grid, if
it provided as part of another field.</p>
<p>The cyclicity of the X axes of the source field and destination
grid is taken into account. If an X axis is in fact cyclic but is
not registered as such by its parent field (see
<a class="reference internal" href="cf.Field.iscyclic.html#cf.Field.iscyclic" title="cf.Field.iscyclic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.Field.iscyclic</span></code></a>), then the cyclicity may be set with the
<em>src_cyclic</em> or <em>dst_cyclic</em> parameters. In the case of two
dimensional latitude and longitude dimension coordinates without
bounds it will be necessary to specify <em>src_cyclic</em> or
<em>dst_cyclic</em> manually if the field is global.</p>
<p>The output field construct’s coordinate objects which span the X
and/or Y axes are replaced with those from the destination
grid. Any fields contained in coordinate reference objects will
also be regridded, if possible.</p>
<p><strong>Mask</strong></p>
<p>The data array mask of the field is automatically taken into
account, such that the regridded data array will be masked in
regions where the input data array is masked. By default the mask
of the destination grid is not taken into account. If the
destination field data has more than two dimensions then the mask,
if used, is taken from the two dimensional section of the data
where the indices of all axes other than X and Y are zero.</p>
<p><strong>Implementation</strong></p>
<p>The interpolation is carried out using the <code class="xref py py-obj docutils literal notranslate"><span class="pre">ESMPy</span></code> package, a
Python interface to the Earth System Modeling Framework (ESMF)
<a class="reference external" href="https://www.earthsystemcog.org/projects/esmf/regridding">regridding utility</a>.</p>
<p><strong>Logging</strong></p>
<p>Whether ESMF logging is enabled or not is determined by
<a class="reference internal" href="../function/cf.regrid_logging.html#cf.regrid_logging" title="cf.regrid_logging"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.regrid_logging</span></code></a>. If it is logging takes place after every
call. By default logging is disabled.</p>
<p><strong>Latitude-Longitude Grid</strong></p>
<p>The canonical grid with independent latitude and longitude
coordinates.</p>
<p><strong>Curvilinear Grids</strong></p>
<p>Grids in projection coordinate systems can be regridded as long as
two dimensional latitude and longitude coordinates are present.</p>
<p><strong>Rotated Pole Grids</strong></p>
<p>Rotated pole grids can be regridded as long as two dimensional
latitude and longitude coordinates are present. It may be
necessary to explicitly identify the grid latitude and grid
longitude coordinates as being the X and Y axes and specify the
<em>src_cyclic</em> or <em>dst_cyclic</em> keywords.</p>
<p><strong>Tripolar Grids</strong></p>
<p>Tripolar grids are logically rectangular and so may be able to be
regridded. If no dimension coordinates are present it will be
necessary to specify which netCDF dimensions are the X and Y axes
using the <em>src_axes</em> or <em>dst_axes</em> keywords. Connections across
the bipole fold are not currently supported, but are not be
necessary in some cases, for example if the points on either side
are together without a gap. It will also be necessary to specify
<em>src_cyclic</em> or <em>dst_cyclic</em> if the grid is global.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.0.4.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="cf.Field.regridc.html#cf.Field.regridc" title="cf.Field.regridc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regridc</span></code></a></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt>dst: <a class="reference internal" href="../class/cf.Field.html#cf.Field" title="cf.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code></a></dt><dd><p>The field containing the new grid. If dst is a field list
the first field in the list is used. Alternatively a
dictionary can be passed containing the keywords
‘longitude’ and ‘latitude’ with either two 1D dimension
coordinates or two 2D auxiliary coordinates. In the 2D
case both coordinates must have their axes in the same
order and this must be specified by the keyword ‘axes’ as
either of the tuples <code class="docutils literal notranslate"><span class="pre">('X',</span> <span class="pre">'Y')</span></code> or <code class="docutils literal notranslate"><span class="pre">('Y',</span> <span class="pre">'X')</span></code>.</p>
</dd>
<dt>method: <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code></a></dt><dd><p>Specify the regridding method. The <em>method</em> parameter must
be one of the following:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 39%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'linear'</span></code></p></td>
<td><p>Bilinear interpolation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'bilinear'</span></code></p></td>
<td><p>Deprecated alias for <code class="docutils literal notranslate"><span class="pre">'linear'</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'conservative_1st'</span></code></p></td>
<td><p>First order conservative
interpolation.</p>
<p>Preserve the area integral of the
data across the interpolation from
source to destination. It uses the
proportion of the area of the
overlapping source and destination
cells to determine appropriate
weights.</p>
<p>In particular, the weight of a
source cell is the ratio of the
area of intersection of the source
and destination cells to the area
of the whole destination cell.</p>
<p>It does not account for the field
gradient across the source cell,
unlike the second-order
conservative method (see below).</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'conservative_2nd'</span></code></p></td>
<td><p>Second-order conservative
interpolation.</p>
<p>As with first order (see above),
preserves the area integral of the
field between source and
destinatio using a weighted sum,
with weights based on the
proportionate area of
intersection.</p>
<p>Unlike first-order, the
second-order method incorporates
further terms to take into
consideration the gradient of the
field across the source cell,
thereby typically producing a
smoother result of higher
accuracy.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'conservative'</span></code></p></td>
<td><p>Alias for <code class="docutils literal notranslate"><span class="pre">'conservative_1st'</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'patch'</span></code></p></td>
<td><p>Higher-order patch recovery
interpolation.</p>
<p>A second degree polynomial
regridding method, which uses a
least squares algorithm to
calculate the polynomial.</p>
<p>This method gives better
derivatives in the resulting
destination data than the linear
method.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'nearest_stod'</span></code></p></td>
<td><p>Nearest neighbour interpolation
for which each destination point
is mapped to the closest source
point.</p>
<p>Useful for extrapolation of
categorical data.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'nearest_dtos'</span></code></p></td>
<td><p>Nearest neighbour interpolation
for which each source point is
mapped to the destination point.</p>
<p>Useful for extrapolation of
categorical data.</p>
<p>A given destination point may
receive input from multiple source
points, but no source point will
map to more than one destination
point.</p>
</td>
</tr>
</tbody>
</table>
</dd>
<dt>src_cyclic: <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, optional</dt><dd><p>Specifies whether the longitude for the source grid is
periodic or not. If <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a> then, if possible, this is
determined automatically otherwise it defaults to False.</p>
</dd>
<dt>dst_cyclic: <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, optional</dt><dd><p>Specifies whether the longitude for the destination grid
is periodic of not. If <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a> then, if possible, this is
determined automatically otherwise it defaults to False.</p>
</dd>
<dt>use_src_mask: <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, optional</dt><dd><p>For all methods other than ‘nearest_stod’, this must be
True as it does not make sense to set it to False. For the
‘nearest_stod’ method if it is True then points in the
result that are nearest to a masked source point are
masked. Otherwise, if it is False, then these points are
interpolated to the nearest unmasked source points.</p>
</dd>
<dt>use_dst_mask: <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, optional</dt><dd><p>By default the mask of the data on the destination grid is
not taken into account when performing regridding. If this
option is set to true then it is. If the destination field
has more than two dimensions then the first 2D slice in
index space is used for the mask e.g. for an field varying
with (X, Y, Z, T) the mask is taken from the slice (X, Y,
0, 0).</p>
</dd>
<dt>fracfield: <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, optional</dt><dd><p>If the method of regridding is conservative the fraction
of each destination grid cell involved in the regridding
is returned instead of the regridded data if this is
True. Otherwise this is ignored.</p>
</dd>
<dt>src_axes: <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code></a>, optional</dt><dd><p>A dictionary specifying the axes of the 2D latitude and
longitude coordinates of the source field when no 1D
dimension coordinates are present. It must have keys
<code class="docutils literal notranslate"><span class="pre">'X'</span></code> and <code class="docutils literal notranslate"><span class="pre">'Y'</span></code>. TODO</p>
<dl class="simple">
<dt><em>Parameter example:</em></dt><dd><p><code class="docutils literal notranslate"><span class="pre">src_axes={'X':</span> <span class="pre">'ncdim%x',</span> <span class="pre">'Y':</span> <span class="pre">'ncdim%y'}</span></code></p>
</dd>
<dt><em>Parameter example:</em></dt><dd><p><code class="docutils literal notranslate"><span class="pre">src_axes={'X':</span> <span class="pre">1,</span> <span class="pre">'Y':</span> <span class="pre">0}</span></code></p>
</dd>
</dl>
</dd>
<dt>dst_axes: <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code></a>, optional</dt><dd><p>A dictionary specifying the axes of the 2D latitude and
longitude coordinates of the destination field when no
dimension coordinates are present. It must have keys
<code class="docutils literal notranslate"><span class="pre">'X'</span></code> and <code class="docutils literal notranslate"><span class="pre">'Y'</span></code>.</p>
<dl class="simple">
<dt><em>Parameter example:</em></dt><dd><p><code class="docutils literal notranslate"><span class="pre">dst_axes={'X':</span> <span class="pre">'ncdim%x',</span> <span class="pre">'Y':</span> <span class="pre">'ncdim%y'}</span></code></p>
</dd>
</dl>
</dd>
<dt>axis_order: sequence, optional</dt><dd><p>A sequence of items specifying dimension coordinates as
retrieved by the <a class="reference internal" href="cf.Field.dim.html#cf.Field.dim" title="cf.Field.dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></a> method. These determine the order
in which to iterate over the other axes of the field when
regridding X-Y slices. The slowest moving axis will be the
first one specified. Currently the regridding weights are
recalculated every time the mask of an X-Y slice changes
with respect to the previous one, so this option allows
the user to minimise how frequently the mask changes.</p>
</dd>
<dt>ignore_degenerate: <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, optional</dt><dd><p>True by default. Instructs ESMPy to ignore degenerate
cells when checking the grids for errors. Regridding will
proceed and degenerate cells will be skipped, not
producing a result, when set to True. Otherwise an error
will be produced if degenerate cells are found. This will
be present in the ESMPy log files if <a class="reference internal" href="../function/cf.regrid_logging.html#cf.regrid_logging" title="cf.regrid_logging"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cf.regrid_logging</span></code></a>
is set to True. As of ESMF 7.0.0 this only applies to
conservative regridding.  Other methods always skip
degenerate cells.</p>
</dd>
<dt>inplace: <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></a>, optional</dt><dd><p>If True then do the operation in-place and return <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>.</p>
</dd>
<dt>i: deprecated at version 3.0.0</dt><dd><p>Use the <em>inplace</em> parameter instead.</p>
</dd>
<dt>_compute_field_mass: <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code></a>, optional</dt><dd><p>If this is a dictionary then the field masses of the
source and destination fields are computed and returned
within the dictionary. The keys of the dictionary
indicates the lat-long slice of the field and the
corresponding value is a tuple containing the source field
construct’s mass and the destination field construct’s
mass. The calculation is only done if conservative
regridding is being performed. This is for debugging
purposes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference internal" href="../class/cf.Field.html#cf.Field" title="cf.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Field</span></code></a></dt><dd><p>The regridded field construct.</p>
</dd>
</dl>
</dd>
</dl>
<p><strong>Examples:</strong></p>
<p>Regrid field construct <code class="docutils literal notranslate"><span class="pre">f</span></code> conservatively onto a grid contained
in field construct <code class="docutils literal notranslate"><span class="pre">g</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">regrids</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s1">&#39;conservative&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Regrid f to the grid of g using linear regridding and forcing
the source field f to be treated as cyclic.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">regrids</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">src_cyclic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Regrid f to the grid of g using the mask of g.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">regrids</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s1">&#39;conservative_1st&#39;</span><span class="p">,</span> <span class="n">use_dst_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Regrid f to 2D auxiliary coordinates lat and lon, which have their
dimensions ordered “Y” first then “X”.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lat</span>
<span class="go">&lt;CF AuxiliaryCoordinate: latitude(110, 106) degrees_north&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lon</span>
<span class="go">&lt;CF AuxiliaryCoordinate: longitude(110, 106) degrees_east&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">regrids</span><span class="p">(</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s1">&#39;longitude&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;axes&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)},</span>
<span class="gp">... </span>        <span class="s1">&#39;conservative&#39;</span>
<span class="gp">... </span>    <span class="p">)</span>
</pre></div>
</div>
<p>Regrid field, f, on tripolar grid to latitude-longitude grid of
field, g.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">regrids</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s1">&#39;linear, src_axes={&#39;</span><span class="n">X</span><span class="s1">&#39;: &#39;</span><span class="n">ncdim</span><span class="o">%</span><span class="n">x</span><span class="s1">&#39;, &#39;</span><span class="n">Y</span><span class="s1">&#39;: &#39;</span><span class="n">ncdim</span><span class="o">%</span><span class="n">y</span><span class="s1">&#39;},</span>
<span class="gp">... </span>              <span class="n">src_cyclic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Regrid f to the grid of g iterating over the ‘Z’ axis last and the
‘T’ axis next to last to minimise the number of times the mask is
changed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">regrids</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s1">&#39;nearest_dtos&#39;</span><span class="p">,</span> <span class="n">axis_order</span><span class="o">=</span><span class="s1">&#39;ZT&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2020, NCAS | Page built on 2020-10-16.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>