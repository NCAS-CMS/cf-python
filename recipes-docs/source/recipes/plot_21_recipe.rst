
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "recipes/plot_21_recipe.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_recipes_plot_21_recipe.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_recipes_plot_21_recipe.py:


Applying functions and mathematical operations to data
======================================================

In this recipe we will explore various methods to apply a mathematical operation or a function to a set of data in a field. For the purposes of the example, we will look at various ways of calculating the sine of each element in a data array.

There are various options to do this, the recommended option is to use `cf native functions <https://ncas-cms.github.io/cf-python/class/cf.Field.html#mathematical-operations>`_, as they preserve units and metadata associated with fields. Sometimes, however, the function you need is not implemented in cf, so there are alternative methods.

.. GENERATED FROM PYTHON SOURCE LINES 11-17

.. figure:: ../images/data-operations-flowchart.png
   :scale: 50 %
   :alt: flowchart showing process of location a function in cf, then in Dask, then in NumPy, and finally vectorising it with NumPy.

   It is recommended to use the highest possible implementation of a given function as shown by the chart.


.. GENERATED FROM PYTHON SOURCE LINES 20-21

1. Import cf-python:

.. GENERATED FROM PYTHON SOURCE LINES 21-24

.. code-block:: Python


    import cf








.. GENERATED FROM PYTHON SOURCE LINES 25-26

2. Read the template field constructs from the example:

.. GENERATED FROM PYTHON SOURCE LINES 26-30

.. code-block:: Python


    f = cf.example_field(1)
    print(f)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Field: air_temperature (ncvar%ta)
    ---------------------------------
    Data            : air_temperature(atmosphere_hybrid_height_coordinate(1), grid_latitude(10), grid_longitude(9)) K
    Cell methods    : grid_latitude(10): grid_longitude(9): mean where land (interval: 0.1 degrees) time(1): maximum
    Field ancils    : air_temperature standard_error(grid_latitude(10), grid_longitude(9)) = [[0.76, ..., 0.32]] K
    Dimension coords: atmosphere_hybrid_height_coordinate(1) = [20.0] m
                    : grid_latitude(10) = [2.2, ..., -1.76] degrees
                    : grid_longitude(9) = [-4.7, ..., -1.18] degrees
                    : time(1) = [2019-01-01 00:00:00]
    Auxiliary coords: latitude(grid_latitude(10), grid_longitude(9)) = [[53.941, ..., 50.225]] degrees_N
                    : longitude(grid_longitude(9), grid_latitude(10)) = [[2.004, ..., 8.156]] degrees_E
                    : long_name=Grid latitude name(grid_latitude(10)) = [--, ..., kappa]
    Cell measures   : measure:area(grid_longitude(9), grid_latitude(10)) = [[2391.9657, ..., 2392.6009]] km2
    Coord references: grid_mapping_name:rotated_latitude_longitude
                    : standard_name:atmosphere_hybrid_height_coordinate
    Domain ancils   : atmosphere_hybrid_height_coordinate(atmosphere_hybrid_height_coordinate(1)) = [20.0] m
                    : ncvar%b(atmosphere_hybrid_height_coordinate(1)) = [0.997741281986237]
                    : surface_altitude(grid_latitude(10), grid_longitude(9)) = [[0.0, ..., 270.0]] m




.. GENERATED FROM PYTHON SOURCE LINES 31-38

1: Native cf
------------

As mentioned, cf supports a handful of `field operations <https://ncas-cms.github.io/cf-python/class/cf.Field.html#mathematical-operations>`_ that automatically update the domain and metadata alongside the data array.

Additionally, where a function or operation has a specific domain, cf will mask any erroneous elements that were not processed properly.


.. GENERATED FROM PYTHON SOURCE LINES 41-42

1. Create an instance of the template field to work with:

.. GENERATED FROM PYTHON SOURCE LINES 42-45

.. code-block:: Python


    field1 = f.copy()








.. GENERATED FROM PYTHON SOURCE LINES 46-47

2. Calculate the sine of the elements in the data array:

.. GENERATED FROM PYTHON SOURCE LINES 47-52

.. code-block:: Python


    new_field = field1.sin()

    print(new_field.data)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[[-0.8883701029239938, ..., -0.459087873911222]]] 1




.. GENERATED FROM PYTHON SOURCE LINES 53-54

Alternatively, we can update the original field in place using the ``inplace`` parameter:

.. GENERATED FROM PYTHON SOURCE LINES 54-65

.. code-block:: Python


    field1.sin(inplace=True)

    print(field1.data)

    # cf will automatically update the units of our field depending on the operation.
    # Here, since the sine is a dimensionless value, we get the units "1".

    print(f.units)  # Original
    print(field1.units)  # After operation





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[[-0.8883701029239938, ..., -0.459087873911222]]] 1
    K
    1




.. GENERATED FROM PYTHON SOURCE LINES 66-84

2: Dask
-------

When it comes to computing mathematical operations on a data array,
cf utilises two different libraries under the hood: Dask and NumPy.

In the event that cf does not natively support an operation, the next
port of call is Dask (or specifically, the``dask.array``module).

Dask implements `a number of functions <https://docs.dask.org/en/stable/array-numpy-compatibility.html>`_, either as pass-throughs for
NumPy functions (see below) or as its own implementations.

To preserve the metadata associated with the origin field, we will
have to create a duplicate of it and rewrite the data array using the
``f.Field.set_data()`` method. However, care must be taken to also
update metadata such as units or coordinates when applying a function
from outside of cf.


.. GENERATED FROM PYTHON SOURCE LINES 87-88

1. Import the necessary Dask module:

.. GENERATED FROM PYTHON SOURCE LINES 88-91

.. code-block:: Python


    import dask as da








.. GENERATED FROM PYTHON SOURCE LINES 92-93

2. Create an instance of the template field to work with:

.. GENERATED FROM PYTHON SOURCE LINES 93-96

.. code-block:: Python


    field2 = f.copy()








.. GENERATED FROM PYTHON SOURCE LINES 97-98

3. Load the data from the field as a Dask array:

.. GENERATED FROM PYTHON SOURCE LINES 98-103

.. code-block:: Python


    data = field2.data

    dask_array = data.to_dask_array()








.. GENERATED FROM PYTHON SOURCE LINES 104-106

4. Create a new field, calculate the sine of the elements,
and write the array to the new field:

.. GENERATED FROM PYTHON SOURCE LINES 106-115

.. code-block:: Python


    new_field = field2.copy()

    calculated_array = da.array.sin(dask_array)

    new_field.set_data(calculated_array)

    print(new_field.data)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[[-0.8883701029239938, ..., -0.459087873911222]]] K




.. GENERATED FROM PYTHON SOURCE LINES 116-117

5. Manually update the units:

.. GENERATED FROM PYTHON SOURCE LINES 117-122

.. code-block:: Python


    new_field.override_units("1", inplace=True)

    print(new_field.units)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1




.. GENERATED FROM PYTHON SOURCE LINES 123-124

To instead update the original field in place, as before:

.. GENERATED FROM PYTHON SOURCE LINES 124-134

.. code-block:: Python


    calculated_array = da.array.sin(dask_array)

    field2.set_data(calculated_array)

    field2.override_units("1", inplace=True)

    print(field2.data)
    print(field2.units)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[[-0.8883701029239938, ..., -0.459087873911222]]] 1
    1




.. GENERATED FROM PYTHON SOURCE LINES 135-146

3: NumPy Universal Functions
----------------------------

Applying an operation with Dask and NumPy is a similar process,
and some Dask functions are effectively aliases for equivalent NumPy
functions. NumPy has so-called `universal functions <https://numpy.org/doc/stable/reference/ufuncs.html>`_ that improve
performance when working on large arrays compared to just iterating
through each element and running a function on it.

As above, take care to manually update any metadata for the new field.


.. GENERATED FROM PYTHON SOURCE LINES 149-150

1. Import NumPy:

.. GENERATED FROM PYTHON SOURCE LINES 150-153

.. code-block:: Python


    import numpy as np








.. GENERATED FROM PYTHON SOURCE LINES 154-155

2. Create an instance of the template field to work with:

.. GENERATED FROM PYTHON SOURCE LINES 155-158

.. code-block:: Python


    field3 = f.copy()








.. GENERATED FROM PYTHON SOURCE LINES 159-161

3. Create a new field, compute the sine of the elements,
and write the array to the new field:

.. GENERATED FROM PYTHON SOURCE LINES 161-170

.. code-block:: Python


    new_field = field3.copy()

    calculated_array = np.sin(field3)

    new_field.set_data(calculated_array)

    print(new_field.data)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[[-0.8883701029239938, ..., -0.459087873911222]]] K




.. GENERATED FROM PYTHON SOURCE LINES 171-172

4. Manually update the units:

.. GENERATED FROM PYTHON SOURCE LINES 172-177

.. code-block:: Python


    new_field.override_units("1", inplace=True)

    print(new_field.units)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1




.. GENERATED FROM PYTHON SOURCE LINES 178-188

4: NumPy Vectorization
----------------------

In the event that the operation you need is not supported in cf, Dask,
or NumPy, then any standard Python function can be vectorized using
NumPy. In essence, this simply allows the function to take an array as
input, and return the updated array as output. There is no improvement
in performance to simply iterating through each element in the data
array and applying the function.


.. GENERATED FROM PYTHON SOURCE LINES 191-192

1. Import our third-party function; here, from the ``math`` module:

.. GENERATED FROM PYTHON SOURCE LINES 192-195

.. code-block:: Python


    import math








.. GENERATED FROM PYTHON SOURCE LINES 196-197

2. Create an instance of the template field to work with:

.. GENERATED FROM PYTHON SOURCE LINES 197-200

.. code-block:: Python


    field4 = f.copy()








.. GENERATED FROM PYTHON SOURCE LINES 201-202

3. Vectorize the function with NumPy:

.. GENERATED FROM PYTHON SOURCE LINES 202-205

.. code-block:: Python


    vectorized_function = np.vectorize(math.sin)








.. GENERATED FROM PYTHON SOURCE LINES 206-208

4. Create a new field, calculate the sine of the elements,
and write the array to the new field:

.. GENERATED FROM PYTHON SOURCE LINES 208-217

.. code-block:: Python


    new_field = field4.copy()

    calculated_array = vectorized_function(field4)

    new_field.set_data(calculated_array)

    print(new_field.data)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[[-0.8883701029239938, ..., -0.459087873911222]]] K




.. GENERATED FROM PYTHON SOURCE LINES 218-219

5. Manually update the units:

.. GENERATED FROM PYTHON SOURCE LINES 219-224

.. code-block:: Python


    new_field.override_units("1", inplace=True)

    print(new_field.units)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1




.. GENERATED FROM PYTHON SOURCE LINES 225-237

Performance
-----------

NumPy and Dask tend to work the quickest thanks to their universal
functions. NumPy vectorization works much slower as functions cannot
be optimised in this fashion.

Operations in cf, whilst running NumPy and Dask under the hood, still
come with all the performance overheads necessary to accurately adapt
metadata between fields to ensure that resultant fields are still
compliant with conventions.



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.094 seconds)


.. _sphx_glr_download_recipes_plot_21_recipe.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_21_recipe.ipynb <plot_21_recipe.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_21_recipe.py <plot_21_recipe.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_21_recipe.zip <plot_21_recipe.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
